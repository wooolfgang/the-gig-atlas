type User {
  id: ID! @id
  firstName: String
  lastName: String
  email: String! @unique
  password: String!
  role: UserRole! @default(value: MEMBER)
  createdAt: DateTime! @createdAt
  
  asEmployer: Employer @unique @relation(name: "AsEmployer", link: INLINE, onDelete: CASCADE)
  asFreelancer: Freelancer @unique @relation(name: "AsFreelancer", link: INLINE, onDelete: CASCADE)
  
  isEmailVerified: Boolean @default(value: false)
  freelancerOnboardingStep:  FreelancerOnboardingStep @default(value: PERSONAL)
}

enum FreelancerOnboardingStep {
  PERSONAL
  PORTFOLIO
  FINISHED
}

enum UserRole {
  ADMIN
  MEMBER
}

type Employer {
  id: ID! @id
  asUser: User @unique @relation(name: "AsEmployer")
  employerType: EmployerType!
  gigs: [Gig]! @relation(name: "GigsOfEmployer", onDelete: CASCADE)
  displayName: String!
  website: String!
  introduction: String!
  email: String!
  avatar: File!
}

enum EmployerType {
  PERSONAL
  COMPANY
}

type Freelancer {
  id: ID! @id
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  asUser: User @unique @relation(name: "AsFreelancer")
  bio: String
  avatar: File
  website: String
  location: String
  timezone: String
  isPrivate: Boolean @default(value: false)
  isForHire: Boolean @default(value: true)
  socials: [Social!] @scalarList(strategy: RELATION)
  skills: [String!] @scalarList(strategy: RELATION)
  portfolio: [PortfolioProject!]
}

type PortfolioProject {
  id: ID! @id
  title: String!
  description: String!
  url: String
  avatar: File @relation(name: "PortfolioAvatar")
  images: [File]! @relation(name: "PortfolioImages")
}

type Social {
  id: ID! @id
  type: SocialType!
  url: String!
}

enum SocialType {
  UPWORK
  GITHUB
  LINKEDIN
  TWITTER
}

enum GigCommunicationType {
  EMAIL
  WEBSITE
  IN_APP
}

type Gig {
  id: ID! @id
  title: String!
  description: String!
  technologies: [String!]! @scalarList(strategy: RELATION)
  projectType: ProjectType!
  paymentType: PaymentType!
  minFee: Float!
  maxFee: Float!
  jobType: JobType!
  locationRestriction: String
  employer: Employer! @relation(name: "GigsOfEmployer")
  createdAt: DateTime! @createdAt
  communicationType: GigCommunicationType! @default(value: EMAIL)
  communicationEmail: String
  communicationWebsite: String
}

enum JobType {
  FULL_TIME
  PART_TIME
  CONTRACT
}

enum PaymentType {
  HOURLY
  FIXED
} 

enum ProjectType {
  GREENFIELD
  MAINTENANCE
  CONSULTING
  TESTING
}

type File {
  id: ID! @id
  createdAt: DateTime! @createdAt 
  updatedAt: DateTime! @updatedAt
  name: String
  contentType: String
  url: String
}

type Product {
  id: ID! @id
  name: String!
  price: Float! #// price to refer for billing cyle in subscription or in order
  codename: String! @unique #// to avoid dublication
  description: String
  createdAt: DateTime! @createdAt 
  updatedAt: DateTime! @updatedAt
}

enum PaymentService {
  PAYPAL
  STRIPE
}

enum PaymentStatus {
  CREATED,
  COMPLETED,
}

type Order {
  id: ID! @id
  payer: User!
  serviceRefId: String! @unique
  service: PaymentService!
  status: PaymentStatus!
  cost: Float!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}


enum PlanStatus { # // determines if plan is currently available or not
  INACTIVE,
  ACTIVE,
}


type Plan { # // Let the user choose the type of plan for their subscription
  id: ID! @id
  codename: String! @unique #// client's static reference rather than by using id
  serviceId: String!
  status: PlanStatus!
  cyclePrice: Float!
  description: String
}

enum SubscriptionStatus {
  CREATED, #// status after created
  APPROVED, #// status after user approved payment
  ACTIVE, #// set to active after confirmed payment
  SUSPENDED, #// says it all
  CANCELLED,
  EXPIRED,
}

type PlanSubscription {
  id: ID! @id
  subscriber: User!
  serviceId: String! @unique
  service: PaymentService!
  status: SubscriptionStatus!
  #// time reference when subscription is still active
  #// shows the remaining time of use after cancelled subscription
  endAt: DateTime!
  plan: Plan! @relation(link: INLINE)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}
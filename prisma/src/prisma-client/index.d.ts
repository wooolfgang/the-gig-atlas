// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  commentVote: (where?: CommentVoteWhereInput) => Promise<boolean>;
  employer: (where?: EmployerWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  freelancer: (where?: FreelancerWhereInput) => Promise<boolean>;
  gig: (where?: GigWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  plan: (where?: PlanWhereInput) => Promise<boolean>;
  planSubscription: (where?: PlanSubscriptionWhereInput) => Promise<boolean>;
  portfolioProject: (where?: PortfolioProjectWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  social: (where?: SocialWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  tagCategory: (where?: TagCategoryWhereInput) => Promise<boolean>;
  thread: (where?: ThreadWhereInput) => Promise<boolean>;
  threadVote: (where?: ThreadVoteWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  commentVote: (
    where: CommentVoteWhereUniqueInput
  ) => CommentVoteNullablePromise;
  commentVotes: (args?: {
    where?: CommentVoteWhereInput;
    orderBy?: CommentVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CommentVote>;
  commentVotesConnection: (args?: {
    where?: CommentVoteWhereInput;
    orderBy?: CommentVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentVoteConnectionPromise;
  employer: (where: EmployerWhereUniqueInput) => EmployerNullablePromise;
  employers: (args?: {
    where?: EmployerWhereInput;
    orderBy?: EmployerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employer>;
  employersConnection: (args?: {
    where?: EmployerWhereInput;
    orderBy?: EmployerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployerConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  freelancer: (where: FreelancerWhereUniqueInput) => FreelancerNullablePromise;
  freelancers: (args?: {
    where?: FreelancerWhereInput;
    orderBy?: FreelancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Freelancer>;
  freelancersConnection: (args?: {
    where?: FreelancerWhereInput;
    orderBy?: FreelancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FreelancerConnectionPromise;
  gig: (where: GigWhereUniqueInput) => GigNullablePromise;
  gigs: (args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Gig>;
  gigsConnection: (args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GigConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  plan: (where: PlanWhereUniqueInput) => PlanNullablePromise;
  plans: (args?: {
    where?: PlanWhereInput;
    orderBy?: PlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Plan>;
  plansConnection: (args?: {
    where?: PlanWhereInput;
    orderBy?: PlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlanConnectionPromise;
  planSubscription: (
    where: PlanSubscriptionWhereUniqueInput
  ) => PlanSubscriptionNullablePromise;
  planSubscriptions: (args?: {
    where?: PlanSubscriptionWhereInput;
    orderBy?: PlanSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlanSubscription>;
  planSubscriptionsConnection: (args?: {
    where?: PlanSubscriptionWhereInput;
    orderBy?: PlanSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlanSubscriptionConnectionPromise;
  portfolioProject: (
    where: PortfolioProjectWhereUniqueInput
  ) => PortfolioProjectNullablePromise;
  portfolioProjects: (args?: {
    where?: PortfolioProjectWhereInput;
    orderBy?: PortfolioProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PortfolioProject>;
  portfolioProjectsConnection: (args?: {
    where?: PortfolioProjectWhereInput;
    orderBy?: PortfolioProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PortfolioProjectConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  social: (where: SocialWhereUniqueInput) => SocialNullablePromise;
  socials: (args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Social>;
  socialsConnection: (args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SocialConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  tagCategory: (
    where: TagCategoryWhereUniqueInput
  ) => TagCategoryNullablePromise;
  tagCategories: (args?: {
    where?: TagCategoryWhereInput;
    orderBy?: TagCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TagCategory>;
  tagCategoriesConnection: (args?: {
    where?: TagCategoryWhereInput;
    orderBy?: TagCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagCategoryConnectionPromise;
  thread: (where: ThreadWhereUniqueInput) => ThreadNullablePromise;
  threads: (args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Thread>;
  threadsConnection: (args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ThreadConnectionPromise;
  threadVote: (where: ThreadVoteWhereUniqueInput) => ThreadVoteNullablePromise;
  threadVotes: (args?: {
    where?: ThreadVoteWhereInput;
    orderBy?: ThreadVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ThreadVote>;
  threadVotesConnection: (args?: {
    where?: ThreadVoteWhereInput;
    orderBy?: ThreadVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ThreadVoteConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommentVote: (data: CommentVoteCreateInput) => CommentVotePromise;
  updateCommentVote: (args: {
    data: CommentVoteUpdateInput;
    where: CommentVoteWhereUniqueInput;
  }) => CommentVotePromise;
  updateManyCommentVotes: (args: {
    data: CommentVoteUpdateManyMutationInput;
    where?: CommentVoteWhereInput;
  }) => BatchPayloadPromise;
  upsertCommentVote: (args: {
    where: CommentVoteWhereUniqueInput;
    create: CommentVoteCreateInput;
    update: CommentVoteUpdateInput;
  }) => CommentVotePromise;
  deleteCommentVote: (where: CommentVoteWhereUniqueInput) => CommentVotePromise;
  deleteManyCommentVotes: (
    where?: CommentVoteWhereInput
  ) => BatchPayloadPromise;
  createEmployer: (data: EmployerCreateInput) => EmployerPromise;
  updateEmployer: (args: {
    data: EmployerUpdateInput;
    where: EmployerWhereUniqueInput;
  }) => EmployerPromise;
  updateManyEmployers: (args: {
    data: EmployerUpdateManyMutationInput;
    where?: EmployerWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployer: (args: {
    where: EmployerWhereUniqueInput;
    create: EmployerCreateInput;
    update: EmployerUpdateInput;
  }) => EmployerPromise;
  deleteEmployer: (where: EmployerWhereUniqueInput) => EmployerPromise;
  deleteManyEmployers: (where?: EmployerWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createFreelancer: (data: FreelancerCreateInput) => FreelancerPromise;
  updateFreelancer: (args: {
    data: FreelancerUpdateInput;
    where: FreelancerWhereUniqueInput;
  }) => FreelancerPromise;
  updateManyFreelancers: (args: {
    data: FreelancerUpdateManyMutationInput;
    where?: FreelancerWhereInput;
  }) => BatchPayloadPromise;
  upsertFreelancer: (args: {
    where: FreelancerWhereUniqueInput;
    create: FreelancerCreateInput;
    update: FreelancerUpdateInput;
  }) => FreelancerPromise;
  deleteFreelancer: (where: FreelancerWhereUniqueInput) => FreelancerPromise;
  deleteManyFreelancers: (where?: FreelancerWhereInput) => BatchPayloadPromise;
  createGig: (data: GigCreateInput) => GigPromise;
  updateGig: (args: {
    data: GigUpdateInput;
    where: GigWhereUniqueInput;
  }) => GigPromise;
  updateManyGigs: (args: {
    data: GigUpdateManyMutationInput;
    where?: GigWhereInput;
  }) => BatchPayloadPromise;
  upsertGig: (args: {
    where: GigWhereUniqueInput;
    create: GigCreateInput;
    update: GigUpdateInput;
  }) => GigPromise;
  deleteGig: (where: GigWhereUniqueInput) => GigPromise;
  deleteManyGigs: (where?: GigWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPlan: (data: PlanCreateInput) => PlanPromise;
  updatePlan: (args: {
    data: PlanUpdateInput;
    where: PlanWhereUniqueInput;
  }) => PlanPromise;
  updateManyPlans: (args: {
    data: PlanUpdateManyMutationInput;
    where?: PlanWhereInput;
  }) => BatchPayloadPromise;
  upsertPlan: (args: {
    where: PlanWhereUniqueInput;
    create: PlanCreateInput;
    update: PlanUpdateInput;
  }) => PlanPromise;
  deletePlan: (where: PlanWhereUniqueInput) => PlanPromise;
  deleteManyPlans: (where?: PlanWhereInput) => BatchPayloadPromise;
  createPlanSubscription: (
    data: PlanSubscriptionCreateInput
  ) => PlanSubscriptionPromise;
  updatePlanSubscription: (args: {
    data: PlanSubscriptionUpdateInput;
    where: PlanSubscriptionWhereUniqueInput;
  }) => PlanSubscriptionPromise;
  updateManyPlanSubscriptions: (args: {
    data: PlanSubscriptionUpdateManyMutationInput;
    where?: PlanSubscriptionWhereInput;
  }) => BatchPayloadPromise;
  upsertPlanSubscription: (args: {
    where: PlanSubscriptionWhereUniqueInput;
    create: PlanSubscriptionCreateInput;
    update: PlanSubscriptionUpdateInput;
  }) => PlanSubscriptionPromise;
  deletePlanSubscription: (
    where: PlanSubscriptionWhereUniqueInput
  ) => PlanSubscriptionPromise;
  deleteManyPlanSubscriptions: (
    where?: PlanSubscriptionWhereInput
  ) => BatchPayloadPromise;
  createPortfolioProject: (
    data: PortfolioProjectCreateInput
  ) => PortfolioProjectPromise;
  updatePortfolioProject: (args: {
    data: PortfolioProjectUpdateInput;
    where: PortfolioProjectWhereUniqueInput;
  }) => PortfolioProjectPromise;
  updateManyPortfolioProjects: (args: {
    data: PortfolioProjectUpdateManyMutationInput;
    where?: PortfolioProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertPortfolioProject: (args: {
    where: PortfolioProjectWhereUniqueInput;
    create: PortfolioProjectCreateInput;
    update: PortfolioProjectUpdateInput;
  }) => PortfolioProjectPromise;
  deletePortfolioProject: (
    where: PortfolioProjectWhereUniqueInput
  ) => PortfolioProjectPromise;
  deleteManyPortfolioProjects: (
    where?: PortfolioProjectWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createSocial: (data: SocialCreateInput) => SocialPromise;
  updateSocial: (args: {
    data: SocialUpdateInput;
    where: SocialWhereUniqueInput;
  }) => SocialPromise;
  updateManySocials: (args: {
    data: SocialUpdateManyMutationInput;
    where?: SocialWhereInput;
  }) => BatchPayloadPromise;
  upsertSocial: (args: {
    where: SocialWhereUniqueInput;
    create: SocialCreateInput;
    update: SocialUpdateInput;
  }) => SocialPromise;
  deleteSocial: (where: SocialWhereUniqueInput) => SocialPromise;
  deleteManySocials: (where?: SocialWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTagCategory: (data: TagCategoryCreateInput) => TagCategoryPromise;
  updateTagCategory: (args: {
    data: TagCategoryUpdateInput;
    where: TagCategoryWhereUniqueInput;
  }) => TagCategoryPromise;
  updateManyTagCategories: (args: {
    data: TagCategoryUpdateManyMutationInput;
    where?: TagCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertTagCategory: (args: {
    where: TagCategoryWhereUniqueInput;
    create: TagCategoryCreateInput;
    update: TagCategoryUpdateInput;
  }) => TagCategoryPromise;
  deleteTagCategory: (where: TagCategoryWhereUniqueInput) => TagCategoryPromise;
  deleteManyTagCategories: (
    where?: TagCategoryWhereInput
  ) => BatchPayloadPromise;
  createThread: (data: ThreadCreateInput) => ThreadPromise;
  updateThread: (args: {
    data: ThreadUpdateInput;
    where: ThreadWhereUniqueInput;
  }) => ThreadPromise;
  updateManyThreads: (args: {
    data: ThreadUpdateManyMutationInput;
    where?: ThreadWhereInput;
  }) => BatchPayloadPromise;
  upsertThread: (args: {
    where: ThreadWhereUniqueInput;
    create: ThreadCreateInput;
    update: ThreadUpdateInput;
  }) => ThreadPromise;
  deleteThread: (where: ThreadWhereUniqueInput) => ThreadPromise;
  deleteManyThreads: (where?: ThreadWhereInput) => BatchPayloadPromise;
  createThreadVote: (data: ThreadVoteCreateInput) => ThreadVotePromise;
  updateThreadVote: (args: {
    data: ThreadVoteUpdateInput;
    where: ThreadVoteWhereUniqueInput;
  }) => ThreadVotePromise;
  updateManyThreadVotes: (args: {
    data: ThreadVoteUpdateManyMutationInput;
    where?: ThreadVoteWhereInput;
  }) => BatchPayloadPromise;
  upsertThreadVote: (args: {
    where: ThreadVoteWhereUniqueInput;
    create: ThreadVoteCreateInput;
    update: ThreadVoteUpdateInput;
  }) => ThreadVotePromise;
  deleteThreadVote: (where: ThreadVoteWhereUniqueInput) => ThreadVotePromise;
  deleteManyThreadVotes: (where?: ThreadVoteWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  commentVote: (
    where?: CommentVoteSubscriptionWhereInput
  ) => CommentVoteSubscriptionPayloadSubscription;
  employer: (
    where?: EmployerSubscriptionWhereInput
  ) => EmployerSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  freelancer: (
    where?: FreelancerSubscriptionWhereInput
  ) => FreelancerSubscriptionPayloadSubscription;
  gig: (
    where?: GigSubscriptionWhereInput
  ) => GigSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  plan: (
    where?: PlanSubscriptionWhereInput
  ) => PlanSubscriptionPayloadSubscription;
  planSubscription: (
    where?: PlanSubscriptionSubscriptionWhereInput
  ) => PlanSubscriptionSubscriptionPayloadSubscription;
  portfolioProject: (
    where?: PortfolioProjectSubscriptionWhereInput
  ) => PortfolioProjectSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  social: (
    where?: SocialSubscriptionWhereInput
  ) => SocialSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  tagCategory: (
    where?: TagCategorySubscriptionWhereInput
  ) => TagCategorySubscriptionPayloadSubscription;
  thread: (
    where?: ThreadSubscriptionWhereInput
  ) => ThreadSubscriptionPayloadSubscription;
  threadVote: (
    where?: ThreadVoteSubscriptionWhereInput
  ) => ThreadVoteSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProjectType =
  | "GREENFIELD"
  | "MAINTENANCE"
  | "CONSULTING"
  | "TESTING";

export type PaymentType = "HOURLY" | "FIXED";

export type JobType = "FULL_TIME" | "PART_TIME" | "CONTRACT";

export type EmployerType = "PERSONAL" | "COMPANY";

export type UserRole = "ADMIN" | "MEMBER";

export type AccountType = "FREELANCER" | "EMPLOYER";

export type SocialType = "UPWORK" | "GITHUB" | "LINKEDIN" | "TWITTER";

export type OnboardingStep = "PERSONAL" | "EMPLOYER" | "FREELANCER";

export type GigStatus = "SAVED" | "POSTED" | "REMOVED";

export type GigCommunicationType = "EMAIL" | "WEBSITE" | "IN_APP";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "isRoot_ASC"
  | "isRoot_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "upvoteCount_ASC"
  | "upvoteCount_DESC"
  | "downvoteCount_ASC"
  | "downvoteCount_DESC";

export type TagOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type ThreadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "body_ASC"
  | "body_DESC"
  | "upvoteCount_ASC"
  | "upvoteCount_DESC"
  | "downvoteCount_ASC"
  | "downvoteCount_DESC";

export type GigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "projectType_ASC"
  | "projectType_DESC"
  | "paymentType_ASC"
  | "paymentType_DESC"
  | "minFee_ASC"
  | "minFee_DESC"
  | "maxFee_ASC"
  | "maxFee_DESC"
  | "jobType_ASC"
  | "jobType_DESC"
  | "locationRestriction_ASC"
  | "locationRestriction_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "communicationType_ASC"
  | "communicationType_DESC"
  | "communicationEmail_ASC"
  | "communicationEmail_DESC"
  | "communicationWebsite_ASC"
  | "communicationWebsite_DESC";

export type SocialOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "url_ASC"
  | "url_DESC";

export type PortfolioProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "contentType_ASC"
  | "contentType_DESC"
  | "url_ASC"
  | "url_DESC";

export type TagCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ThreadVoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type CommentVoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type EmployerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "employerType_ASC"
  | "employerType_DESC"
  | "introduction_ASC"
  | "introduction_DESC"
  | "email_ASC"
  | "email_DESC"
  | "website_ASC"
  | "website_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FreelancerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "website_ASC"
  | "website_DESC"
  | "location_ASC"
  | "location_DESC"
  | "timezone_ASC"
  | "timezone_DESC"
  | "isPrivate_ASC"
  | "isPrivate_DESC"
  | "isForHire_ASC"
  | "isForHire_DESC";

export type PaymentService = "PAYPAL" | "STRIPE";

export type PaymentStatus = "CREATED" | "COMPLETED";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "serviceRefId_ASC"
  | "serviceRefId_DESC"
  | "service_ASC"
  | "service_DESC"
  | "status_ASC"
  | "status_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlanStatus = "INACTIVE" | "ACTIVE";

export type PlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "codename_ASC"
  | "codename_DESC"
  | "serviceId_ASC"
  | "serviceId_DESC"
  | "status_ASC"
  | "status_DESC"
  | "cyclePrice_ASC"
  | "cyclePrice_DESC"
  | "description_ASC"
  | "description_DESC";

export type SubscriptionStatus =
  | "CREATED"
  | "APPROVED"
  | "ACTIVE"
  | "SUSPENDED"
  | "CANCELLED"
  | "EXPIRED";

export type PlanSubscriptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "serviceId_ASC"
  | "serviceId_DESC"
  | "service_ASC"
  | "service_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "codename_ASC"
  | "codename_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "accountType_ASC"
  | "accountType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "isEmailVerified_ASC"
  | "isEmailVerified_DESC"
  | "onboardingStep_ASC"
  | "onboardingStep_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isRoot_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  upvoteCount_not?: Maybe<Int>;
  upvoteCount_in?: Maybe<Int[] | Int>;
  upvoteCount_not_in?: Maybe<Int[] | Int>;
  upvoteCount_lt?: Maybe<Int>;
  upvoteCount_lte?: Maybe<Int>;
  upvoteCount_gt?: Maybe<Int>;
  upvoteCount_gte?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  downvoteCount_not?: Maybe<Int>;
  downvoteCount_in?: Maybe<Int[] | Int>;
  downvoteCount_not_in?: Maybe<Int[] | Int>;
  downvoteCount_lt?: Maybe<Int>;
  downvoteCount_lte?: Maybe<Int>;
  downvoteCount_gt?: Maybe<Int>;
  downvoteCount_gte?: Maybe<Int>;
  children_every?: Maybe<CommentWhereInput>;
  children_some?: Maybe<CommentWhereInput>;
  children_none?: Maybe<CommentWhereInput>;
  parent?: Maybe<CommentWhereInput>;
  thread?: Maybe<ThreadWhereInput>;
  postedBy?: Maybe<UserWhereInput>;
  votes_every?: Maybe<CommentVoteWhereInput>;
  votes_some?: Maybe<CommentVoteWhereInput>;
  votes_none?: Maybe<CommentVoteWhereInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface ThreadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  upvoteCount_not?: Maybe<Int>;
  upvoteCount_in?: Maybe<Int[] | Int>;
  upvoteCount_not_in?: Maybe<Int[] | Int>;
  upvoteCount_lt?: Maybe<Int>;
  upvoteCount_lte?: Maybe<Int>;
  upvoteCount_gt?: Maybe<Int>;
  upvoteCount_gte?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  downvoteCount_not?: Maybe<Int>;
  downvoteCount_in?: Maybe<Int[] | Int>;
  downvoteCount_not_in?: Maybe<Int[] | Int>;
  downvoteCount_lt?: Maybe<Int>;
  downvoteCount_lte?: Maybe<Int>;
  downvoteCount_gt?: Maybe<Int>;
  downvoteCount_gte?: Maybe<Int>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  postedBy?: Maybe<UserWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  votes_every?: Maybe<ThreadVoteWhereInput>;
  votes_some?: Maybe<ThreadVoteWhereInput>;
  votes_none?: Maybe<ThreadVoteWhereInput>;
  AND?: Maybe<ThreadWhereInput[] | ThreadWhereInput>;
  OR?: Maybe<ThreadWhereInput[] | ThreadWhereInput>;
  NOT?: Maybe<ThreadWhereInput[] | ThreadWhereInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  threads_every?: Maybe<ThreadWhereInput>;
  threads_some?: Maybe<ThreadWhereInput>;
  threads_none?: Maybe<ThreadWhereInput>;
  gigs_every?: Maybe<GigWhereInput>;
  gigs_some?: Maybe<GigWhereInput>;
  gigs_none?: Maybe<GigWhereInput>;
  categories_every?: Maybe<TagCategoryWhereInput>;
  categories_some?: Maybe<TagCategoryWhereInput>;
  categories_none?: Maybe<TagCategoryWhereInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface GigWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  projectType?: Maybe<ProjectType>;
  projectType_not?: Maybe<ProjectType>;
  projectType_in?: Maybe<ProjectType[] | ProjectType>;
  projectType_not_in?: Maybe<ProjectType[] | ProjectType>;
  paymentType?: Maybe<PaymentType>;
  paymentType_not?: Maybe<PaymentType>;
  paymentType_in?: Maybe<PaymentType[] | PaymentType>;
  paymentType_not_in?: Maybe<PaymentType[] | PaymentType>;
  minFee?: Maybe<Float>;
  minFee_not?: Maybe<Float>;
  minFee_in?: Maybe<Float[] | Float>;
  minFee_not_in?: Maybe<Float[] | Float>;
  minFee_lt?: Maybe<Float>;
  minFee_lte?: Maybe<Float>;
  minFee_gt?: Maybe<Float>;
  minFee_gte?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  maxFee_not?: Maybe<Float>;
  maxFee_in?: Maybe<Float[] | Float>;
  maxFee_not_in?: Maybe<Float[] | Float>;
  maxFee_lt?: Maybe<Float>;
  maxFee_lte?: Maybe<Float>;
  maxFee_gt?: Maybe<Float>;
  maxFee_gte?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  jobType_not?: Maybe<JobType>;
  jobType_in?: Maybe<JobType[] | JobType>;
  jobType_not_in?: Maybe<JobType[] | JobType>;
  locationRestriction?: Maybe<String>;
  locationRestriction_not?: Maybe<String>;
  locationRestriction_in?: Maybe<String[] | String>;
  locationRestriction_not_in?: Maybe<String[] | String>;
  locationRestriction_lt?: Maybe<String>;
  locationRestriction_lte?: Maybe<String>;
  locationRestriction_gt?: Maybe<String>;
  locationRestriction_gte?: Maybe<String>;
  locationRestriction_contains?: Maybe<String>;
  locationRestriction_not_contains?: Maybe<String>;
  locationRestriction_starts_with?: Maybe<String>;
  locationRestriction_not_starts_with?: Maybe<String>;
  locationRestriction_ends_with?: Maybe<String>;
  locationRestriction_not_ends_with?: Maybe<String>;
  employer?: Maybe<EmployerWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<GigStatus>;
  status_not?: Maybe<GigStatus>;
  status_in?: Maybe<GigStatus[] | GigStatus>;
  status_not_in?: Maybe<GigStatus[] | GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationType_not?: Maybe<GigCommunicationType>;
  communicationType_in?: Maybe<GigCommunicationType[] | GigCommunicationType>;
  communicationType_not_in?: Maybe<
    GigCommunicationType[] | GigCommunicationType
  >;
  communicationEmail?: Maybe<String>;
  communicationEmail_not?: Maybe<String>;
  communicationEmail_in?: Maybe<String[] | String>;
  communicationEmail_not_in?: Maybe<String[] | String>;
  communicationEmail_lt?: Maybe<String>;
  communicationEmail_lte?: Maybe<String>;
  communicationEmail_gt?: Maybe<String>;
  communicationEmail_gte?: Maybe<String>;
  communicationEmail_contains?: Maybe<String>;
  communicationEmail_not_contains?: Maybe<String>;
  communicationEmail_starts_with?: Maybe<String>;
  communicationEmail_not_starts_with?: Maybe<String>;
  communicationEmail_ends_with?: Maybe<String>;
  communicationEmail_not_ends_with?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
  communicationWebsite_not?: Maybe<String>;
  communicationWebsite_in?: Maybe<String[] | String>;
  communicationWebsite_not_in?: Maybe<String[] | String>;
  communicationWebsite_lt?: Maybe<String>;
  communicationWebsite_lte?: Maybe<String>;
  communicationWebsite_gt?: Maybe<String>;
  communicationWebsite_gte?: Maybe<String>;
  communicationWebsite_contains?: Maybe<String>;
  communicationWebsite_not_contains?: Maybe<String>;
  communicationWebsite_starts_with?: Maybe<String>;
  communicationWebsite_not_starts_with?: Maybe<String>;
  communicationWebsite_ends_with?: Maybe<String>;
  communicationWebsite_not_ends_with?: Maybe<String>;
  AND?: Maybe<GigWhereInput[] | GigWhereInput>;
  OR?: Maybe<GigWhereInput[] | GigWhereInput>;
  NOT?: Maybe<GigWhereInput[] | GigWhereInput>;
}

export interface EmployerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  employerType?: Maybe<EmployerType>;
  employerType_not?: Maybe<EmployerType>;
  employerType_in?: Maybe<EmployerType[] | EmployerType>;
  employerType_not_in?: Maybe<EmployerType[] | EmployerType>;
  introduction?: Maybe<String>;
  introduction_not?: Maybe<String>;
  introduction_in?: Maybe<String[] | String>;
  introduction_not_in?: Maybe<String[] | String>;
  introduction_lt?: Maybe<String>;
  introduction_lte?: Maybe<String>;
  introduction_gt?: Maybe<String>;
  introduction_gte?: Maybe<String>;
  introduction_contains?: Maybe<String>;
  introduction_not_contains?: Maybe<String>;
  introduction_starts_with?: Maybe<String>;
  introduction_not_starts_with?: Maybe<String>;
  introduction_ends_with?: Maybe<String>;
  introduction_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  asUser?: Maybe<UserWhereInput>;
  gigs_every?: Maybe<GigWhereInput>;
  gigs_some?: Maybe<GigWhereInput>;
  gigs_none?: Maybe<GigWhereInput>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  avatar?: Maybe<FileWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmployerWhereInput[] | EmployerWhereInput>;
  OR?: Maybe<EmployerWhereInput[] | EmployerWhereInput>;
  NOT?: Maybe<EmployerWhereInput[] | EmployerWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  accountType?: Maybe<AccountType>;
  accountType_not?: Maybe<AccountType>;
  accountType_in?: Maybe<AccountType[] | AccountType>;
  accountType_not_in?: Maybe<AccountType[] | AccountType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  avatar?: Maybe<FileWhereInput>;
  asEmployer?: Maybe<EmployerWhereInput>;
  asFreelancer?: Maybe<FreelancerWhereInput>;
  isEmailVerified?: Maybe<Boolean>;
  isEmailVerified_not?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  onboardingStep_not?: Maybe<OnboardingStep>;
  onboardingStep_in?: Maybe<OnboardingStep[] | OnboardingStep>;
  onboardingStep_not_in?: Maybe<OnboardingStep[] | OnboardingStep>;
  threads_every?: Maybe<ThreadWhereInput>;
  threads_some?: Maybe<ThreadWhereInput>;
  threads_none?: Maybe<ThreadWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  contentType?: Maybe<String>;
  contentType_not?: Maybe<String>;
  contentType_in?: Maybe<String[] | String>;
  contentType_not_in?: Maybe<String[] | String>;
  contentType_lt?: Maybe<String>;
  contentType_lte?: Maybe<String>;
  contentType_gt?: Maybe<String>;
  contentType_gte?: Maybe<String>;
  contentType_contains?: Maybe<String>;
  contentType_not_contains?: Maybe<String>;
  contentType_starts_with?: Maybe<String>;
  contentType_not_starts_with?: Maybe<String>;
  contentType_ends_with?: Maybe<String>;
  contentType_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface FreelancerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  asUser?: Maybe<UserWhereInput>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  timezone?: Maybe<String>;
  timezone_not?: Maybe<String>;
  timezone_in?: Maybe<String[] | String>;
  timezone_not_in?: Maybe<String[] | String>;
  timezone_lt?: Maybe<String>;
  timezone_lte?: Maybe<String>;
  timezone_gt?: Maybe<String>;
  timezone_gte?: Maybe<String>;
  timezone_contains?: Maybe<String>;
  timezone_not_contains?: Maybe<String>;
  timezone_starts_with?: Maybe<String>;
  timezone_not_starts_with?: Maybe<String>;
  timezone_ends_with?: Maybe<String>;
  timezone_not_ends_with?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  isForHire_not?: Maybe<Boolean>;
  socials_every?: Maybe<SocialWhereInput>;
  socials_some?: Maybe<SocialWhereInput>;
  socials_none?: Maybe<SocialWhereInput>;
  portfolio_every?: Maybe<PortfolioProjectWhereInput>;
  portfolio_some?: Maybe<PortfolioProjectWhereInput>;
  portfolio_none?: Maybe<PortfolioProjectWhereInput>;
  AND?: Maybe<FreelancerWhereInput[] | FreelancerWhereInput>;
  OR?: Maybe<FreelancerWhereInput[] | FreelancerWhereInput>;
  NOT?: Maybe<FreelancerWhereInput[] | FreelancerWhereInput>;
}

export interface SocialWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<SocialType>;
  type_not?: Maybe<SocialType>;
  type_in?: Maybe<SocialType[] | SocialType>;
  type_not_in?: Maybe<SocialType[] | SocialType>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  freelancer?: Maybe<FreelancerWhereInput>;
  AND?: Maybe<SocialWhereInput[] | SocialWhereInput>;
  OR?: Maybe<SocialWhereInput[] | SocialWhereInput>;
  NOT?: Maybe<SocialWhereInput[] | SocialWhereInput>;
}

export interface PortfolioProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  avatar?: Maybe<FileWhereInput>;
  images_every?: Maybe<FileWhereInput>;
  images_some?: Maybe<FileWhereInput>;
  images_none?: Maybe<FileWhereInput>;
  freelancer?: Maybe<FreelancerWhereInput>;
  AND?: Maybe<PortfolioProjectWhereInput[] | PortfolioProjectWhereInput>;
  OR?: Maybe<PortfolioProjectWhereInput[] | PortfolioProjectWhereInput>;
  NOT?: Maybe<PortfolioProjectWhereInput[] | PortfolioProjectWhereInput>;
}

export interface TagCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  AND?: Maybe<TagCategoryWhereInput[] | TagCategoryWhereInput>;
  OR?: Maybe<TagCategoryWhereInput[] | TagCategoryWhereInput>;
  NOT?: Maybe<TagCategoryWhereInput[] | TagCategoryWhereInput>;
}

export interface ThreadVoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  thread?: Maybe<ThreadWhereInput>;
  AND?: Maybe<ThreadVoteWhereInput[] | ThreadVoteWhereInput>;
  OR?: Maybe<ThreadVoteWhereInput[] | ThreadVoteWhereInput>;
  NOT?: Maybe<ThreadVoteWhereInput[] | ThreadVoteWhereInput>;
}

export interface CommentVoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  comment?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentVoteWhereInput[] | CommentVoteWhereInput>;
  OR?: Maybe<CommentVoteWhereInput[] | CommentVoteWhereInput>;
  NOT?: Maybe<CommentVoteWhereInput[] | CommentVoteWhereInput>;
}

export type CommentVoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EmployerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FreelancerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GigWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  serviceRefId?: Maybe<String>;
}>;

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  payer?: Maybe<UserWhereInput>;
  serviceRefId?: Maybe<String>;
  serviceRefId_not?: Maybe<String>;
  serviceRefId_in?: Maybe<String[] | String>;
  serviceRefId_not_in?: Maybe<String[] | String>;
  serviceRefId_lt?: Maybe<String>;
  serviceRefId_lte?: Maybe<String>;
  serviceRefId_gt?: Maybe<String>;
  serviceRefId_gte?: Maybe<String>;
  serviceRefId_contains?: Maybe<String>;
  serviceRefId_not_contains?: Maybe<String>;
  serviceRefId_starts_with?: Maybe<String>;
  serviceRefId_not_starts_with?: Maybe<String>;
  serviceRefId_ends_with?: Maybe<String>;
  serviceRefId_not_ends_with?: Maybe<String>;
  service?: Maybe<PaymentService>;
  service_not?: Maybe<PaymentService>;
  service_in?: Maybe<PaymentService[] | PaymentService>;
  service_not_in?: Maybe<PaymentService[] | PaymentService>;
  status?: Maybe<PaymentStatus>;
  status_not?: Maybe<PaymentStatus>;
  status_in?: Maybe<PaymentStatus[] | PaymentStatus>;
  status_not_in?: Maybe<PaymentStatus[] | PaymentStatus>;
  cost?: Maybe<Float>;
  cost_not?: Maybe<Float>;
  cost_in?: Maybe<Float[] | Float>;
  cost_not_in?: Maybe<Float[] | Float>;
  cost_lt?: Maybe<Float>;
  cost_lte?: Maybe<Float>;
  cost_gt?: Maybe<Float>;
  cost_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export type PlanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  codename?: Maybe<String>;
}>;

export interface PlanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  codename?: Maybe<String>;
  codename_not?: Maybe<String>;
  codename_in?: Maybe<String[] | String>;
  codename_not_in?: Maybe<String[] | String>;
  codename_lt?: Maybe<String>;
  codename_lte?: Maybe<String>;
  codename_gt?: Maybe<String>;
  codename_gte?: Maybe<String>;
  codename_contains?: Maybe<String>;
  codename_not_contains?: Maybe<String>;
  codename_starts_with?: Maybe<String>;
  codename_not_starts_with?: Maybe<String>;
  codename_ends_with?: Maybe<String>;
  codename_not_ends_with?: Maybe<String>;
  serviceId?: Maybe<String>;
  serviceId_not?: Maybe<String>;
  serviceId_in?: Maybe<String[] | String>;
  serviceId_not_in?: Maybe<String[] | String>;
  serviceId_lt?: Maybe<String>;
  serviceId_lte?: Maybe<String>;
  serviceId_gt?: Maybe<String>;
  serviceId_gte?: Maybe<String>;
  serviceId_contains?: Maybe<String>;
  serviceId_not_contains?: Maybe<String>;
  serviceId_starts_with?: Maybe<String>;
  serviceId_not_starts_with?: Maybe<String>;
  serviceId_ends_with?: Maybe<String>;
  serviceId_not_ends_with?: Maybe<String>;
  status?: Maybe<PlanStatus>;
  status_not?: Maybe<PlanStatus>;
  status_in?: Maybe<PlanStatus[] | PlanStatus>;
  status_not_in?: Maybe<PlanStatus[] | PlanStatus>;
  cyclePrice?: Maybe<Float>;
  cyclePrice_not?: Maybe<Float>;
  cyclePrice_in?: Maybe<Float[] | Float>;
  cyclePrice_not_in?: Maybe<Float[] | Float>;
  cyclePrice_lt?: Maybe<Float>;
  cyclePrice_lte?: Maybe<Float>;
  cyclePrice_gt?: Maybe<Float>;
  cyclePrice_gte?: Maybe<Float>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<PlanWhereInput[] | PlanWhereInput>;
  OR?: Maybe<PlanWhereInput[] | PlanWhereInput>;
  NOT?: Maybe<PlanWhereInput[] | PlanWhereInput>;
}

export type PlanSubscriptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  serviceId?: Maybe<String>;
}>;

export interface PlanSubscriptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subscriber?: Maybe<UserWhereInput>;
  serviceId?: Maybe<String>;
  serviceId_not?: Maybe<String>;
  serviceId_in?: Maybe<String[] | String>;
  serviceId_not_in?: Maybe<String[] | String>;
  serviceId_lt?: Maybe<String>;
  serviceId_lte?: Maybe<String>;
  serviceId_gt?: Maybe<String>;
  serviceId_gte?: Maybe<String>;
  serviceId_contains?: Maybe<String>;
  serviceId_not_contains?: Maybe<String>;
  serviceId_starts_with?: Maybe<String>;
  serviceId_not_starts_with?: Maybe<String>;
  serviceId_ends_with?: Maybe<String>;
  serviceId_not_ends_with?: Maybe<String>;
  service?: Maybe<PaymentService>;
  service_not?: Maybe<PaymentService>;
  service_in?: Maybe<PaymentService[] | PaymentService>;
  service_not_in?: Maybe<PaymentService[] | PaymentService>;
  status?: Maybe<SubscriptionStatus>;
  status_not?: Maybe<SubscriptionStatus>;
  status_in?: Maybe<SubscriptionStatus[] | SubscriptionStatus>;
  status_not_in?: Maybe<SubscriptionStatus[] | SubscriptionStatus>;
  gig?: Maybe<GigWhereInput>;
  plan?: Maybe<PlanWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput>;
  OR?: Maybe<PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput>;
  NOT?: Maybe<PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput>;
}

export type PortfolioProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  codename?: Maybe<String>;
}>;

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  codename?: Maybe<String>;
  codename_not?: Maybe<String>;
  codename_in?: Maybe<String[] | String>;
  codename_not_in?: Maybe<String[] | String>;
  codename_lt?: Maybe<String>;
  codename_lte?: Maybe<String>;
  codename_gt?: Maybe<String>;
  codename_gte?: Maybe<String>;
  codename_contains?: Maybe<String>;
  codename_not_contains?: Maybe<String>;
  codename_starts_with?: Maybe<String>;
  codename_not_starts_with?: Maybe<String>;
  codename_ends_with?: Maybe<String>;
  codename_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export type SocialWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type TagCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ThreadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ThreadVoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  isRoot: Boolean;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentCreateManyWithoutParentInput>;
  parent?: Maybe<CommentCreateOneWithoutChildrenInput>;
  thread: ThreadCreateOneWithoutCommentsInput;
  postedBy: UserCreateOneWithoutCommentsInput;
  votes?: Maybe<CommentVoteCreateManyWithoutCommentInput>;
}

export interface CommentCreateManyWithoutParentInput {
  create?: Maybe<
    CommentCreateWithoutParentInput[] | CommentCreateWithoutParentInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  text: String;
  isRoot: Boolean;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentCreateManyWithoutParentInput>;
  thread: ThreadCreateOneWithoutCommentsInput;
  postedBy: UserCreateOneWithoutCommentsInput;
  votes?: Maybe<CommentVoteCreateManyWithoutCommentInput>;
}

export interface ThreadCreateOneWithoutCommentsInput {
  create?: Maybe<ThreadCreateWithoutCommentsInput>;
  connect?: Maybe<ThreadWhereUniqueInput>;
}

export interface ThreadCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  title: String;
  body: String;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagCreateManyWithoutThreadsInput>;
  postedBy: UserCreateOneWithoutThreadsInput;
  votes?: Maybe<ThreadVoteCreateManyWithoutThreadInput>;
}

export interface TagCreateManyWithoutThreadsInput {
  create?: Maybe<TagCreateWithoutThreadsInput[] | TagCreateWithoutThreadsInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateWithoutThreadsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  gigs?: Maybe<GigCreateManyInput>;
  categories?: Maybe<TagCategoryCreateManyWithoutTagsInput>;
}

export interface GigCreateManyInput {
  create?: Maybe<GigCreateInput[] | GigCreateInput>;
  connect?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
}

export interface GigCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  technologies?: Maybe<GigCreatetechnologiesInput>;
  projectType: ProjectType;
  paymentType: PaymentType;
  minFee: Float;
  maxFee: Float;
  jobType: JobType;
  locationRestriction?: Maybe<String>;
  employer: EmployerCreateOneWithoutGigsInput;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface GigCreatetechnologiesInput {
  set?: Maybe<String[] | String>;
}

export interface EmployerCreateOneWithoutGigsInput {
  create?: Maybe<EmployerCreateWithoutGigsInput>;
  connect?: Maybe<EmployerWhereUniqueInput>;
}

export interface EmployerCreateWithoutGigsInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  employerType: EmployerType;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  asUser?: Maybe<UserCreateOneWithoutAsEmployerInput>;
  website?: Maybe<String>;
  avatar?: Maybe<FileCreateOneInput>;
}

export interface UserCreateOneWithoutAsEmployerInput {
  create?: Maybe<UserCreateWithoutAsEmployerInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutAsEmployerInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email: String;
  password: String;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileCreateOneInput>;
  asFreelancer?: Maybe<FreelancerCreateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadCreateManyWithoutPostedByInput>;
  comments?: Maybe<CommentCreateManyWithoutPostedByInput>;
}

export interface FileCreateOneInput {
  create?: Maybe<FileCreateInput>;
  connect?: Maybe<FileWhereUniqueInput>;
}

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  contentType?: Maybe<String>;
  url?: Maybe<String>;
}

export interface FreelancerCreateOneWithoutAsUserInput {
  create?: Maybe<FreelancerCreateWithoutAsUserInput>;
  connect?: Maybe<FreelancerWhereUniqueInput>;
}

export interface FreelancerCreateWithoutAsUserInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerCreateskillsInput>;
  socials?: Maybe<SocialCreateManyWithoutFreelancerInput>;
  portfolio?: Maybe<PortfolioProjectCreateManyWithoutFreelancerInput>;
}

export interface FreelancerCreateskillsInput {
  set?: Maybe<String[] | String>;
}

export interface SocialCreateManyWithoutFreelancerInput {
  create?: Maybe<
    SocialCreateWithoutFreelancerInput[] | SocialCreateWithoutFreelancerInput
  >;
  connect?: Maybe<SocialWhereUniqueInput[] | SocialWhereUniqueInput>;
}

export interface SocialCreateWithoutFreelancerInput {
  id?: Maybe<ID_Input>;
  type: SocialType;
  url: String;
}

export interface PortfolioProjectCreateManyWithoutFreelancerInput {
  create?: Maybe<
    | PortfolioProjectCreateWithoutFreelancerInput[]
    | PortfolioProjectCreateWithoutFreelancerInput
  >;
  connect?: Maybe<
    PortfolioProjectWhereUniqueInput[] | PortfolioProjectWhereUniqueInput
  >;
}

export interface PortfolioProjectCreateWithoutFreelancerInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  url?: Maybe<String>;
  avatar?: Maybe<FileCreateOneInput>;
  images?: Maybe<FileCreateManyInput>;
}

export interface FileCreateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface ThreadCreateManyWithoutPostedByInput {
  create?: Maybe<
    ThreadCreateWithoutPostedByInput[] | ThreadCreateWithoutPostedByInput
  >;
  connect?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
}

export interface ThreadCreateWithoutPostedByInput {
  id?: Maybe<ID_Input>;
  title: String;
  body: String;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagCreateManyWithoutThreadsInput>;
  comments?: Maybe<CommentCreateManyWithoutThreadInput>;
  votes?: Maybe<ThreadVoteCreateManyWithoutThreadInput>;
}

export interface CommentCreateManyWithoutThreadInput {
  create?: Maybe<
    CommentCreateWithoutThreadInput[] | CommentCreateWithoutThreadInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutThreadInput {
  id?: Maybe<ID_Input>;
  text: String;
  isRoot: Boolean;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentCreateManyWithoutParentInput>;
  parent?: Maybe<CommentCreateOneWithoutChildrenInput>;
  postedBy: UserCreateOneWithoutCommentsInput;
  votes?: Maybe<CommentVoteCreateManyWithoutCommentInput>;
}

export interface CommentCreateOneWithoutChildrenInput {
  create?: Maybe<CommentCreateWithoutChildrenInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutChildrenInput {
  id?: Maybe<ID_Input>;
  text: String;
  isRoot: Boolean;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  parent?: Maybe<CommentCreateOneWithoutChildrenInput>;
  thread: ThreadCreateOneWithoutCommentsInput;
  postedBy: UserCreateOneWithoutCommentsInput;
  votes?: Maybe<CommentVoteCreateManyWithoutCommentInput>;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email: String;
  password: String;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileCreateOneInput>;
  asEmployer?: Maybe<EmployerCreateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerCreateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadCreateManyWithoutPostedByInput>;
}

export interface EmployerCreateOneWithoutAsUserInput {
  create?: Maybe<EmployerCreateWithoutAsUserInput>;
  connect?: Maybe<EmployerWhereUniqueInput>;
}

export interface EmployerCreateWithoutAsUserInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  employerType: EmployerType;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  gigs?: Maybe<GigCreateManyWithoutEmployerInput>;
  website?: Maybe<String>;
  avatar?: Maybe<FileCreateOneInput>;
}

export interface GigCreateManyWithoutEmployerInput {
  create?: Maybe<
    GigCreateWithoutEmployerInput[] | GigCreateWithoutEmployerInput
  >;
  connect?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
}

export interface GigCreateWithoutEmployerInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  technologies?: Maybe<GigCreatetechnologiesInput>;
  projectType: ProjectType;
  paymentType: PaymentType;
  minFee: Float;
  maxFee: Float;
  jobType: JobType;
  locationRestriction?: Maybe<String>;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface CommentVoteCreateManyWithoutCommentInput {
  create?: Maybe<
    | CommentVoteCreateWithoutCommentInput[]
    | CommentVoteCreateWithoutCommentInput
  >;
  connect?: Maybe<CommentVoteWhereUniqueInput[] | CommentVoteWhereUniqueInput>;
}

export interface CommentVoteCreateWithoutCommentInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  value: Int;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email: String;
  password: String;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileCreateOneInput>;
  asEmployer?: Maybe<EmployerCreateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerCreateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadCreateManyWithoutPostedByInput>;
  comments?: Maybe<CommentCreateManyWithoutPostedByInput>;
}

export interface CommentCreateManyWithoutPostedByInput {
  create?: Maybe<
    CommentCreateWithoutPostedByInput[] | CommentCreateWithoutPostedByInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutPostedByInput {
  id?: Maybe<ID_Input>;
  text: String;
  isRoot: Boolean;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentCreateManyWithoutParentInput>;
  parent?: Maybe<CommentCreateOneWithoutChildrenInput>;
  thread: ThreadCreateOneWithoutCommentsInput;
  votes?: Maybe<CommentVoteCreateManyWithoutCommentInput>;
}

export interface ThreadVoteCreateManyWithoutThreadInput {
  create?: Maybe<
    ThreadVoteCreateWithoutThreadInput[] | ThreadVoteCreateWithoutThreadInput
  >;
  connect?: Maybe<ThreadVoteWhereUniqueInput[] | ThreadVoteWhereUniqueInput>;
}

export interface ThreadVoteCreateWithoutThreadInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  value: Int;
}

export interface TagCategoryCreateManyWithoutTagsInput {
  create?: Maybe<
    TagCategoryCreateWithoutTagsInput[] | TagCategoryCreateWithoutTagsInput
  >;
  connect?: Maybe<TagCategoryWhereUniqueInput[] | TagCategoryWhereUniqueInput>;
}

export interface TagCategoryCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface UserCreateOneWithoutThreadsInput {
  create?: Maybe<UserCreateWithoutThreadsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutThreadsInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email: String;
  password: String;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileCreateOneInput>;
  asEmployer?: Maybe<EmployerCreateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerCreateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  comments?: Maybe<CommentCreateManyWithoutPostedByInput>;
}

export interface CommentUpdateInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentUpdateManyWithoutParentInput>;
  parent?: Maybe<CommentUpdateOneWithoutChildrenInput>;
  thread?: Maybe<ThreadUpdateOneRequiredWithoutCommentsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<CommentVoteUpdateManyWithoutCommentInput>;
}

export interface CommentUpdateManyWithoutParentInput {
  create?: Maybe<
    CommentCreateWithoutParentInput[] | CommentCreateWithoutParentInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutParentInput[]
    | CommentUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutParentInput[]
    | CommentUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutParentInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutParentDataInput;
}

export interface CommentUpdateWithoutParentDataInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentUpdateManyWithoutParentInput>;
  thread?: Maybe<ThreadUpdateOneRequiredWithoutCommentsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<CommentVoteUpdateManyWithoutCommentInput>;
}

export interface ThreadUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<ThreadCreateWithoutCommentsInput>;
  update?: Maybe<ThreadUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<ThreadUpsertWithoutCommentsInput>;
  connect?: Maybe<ThreadWhereUniqueInput>;
}

export interface ThreadUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagUpdateManyWithoutThreadsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutThreadsInput>;
  votes?: Maybe<ThreadVoteUpdateManyWithoutThreadInput>;
}

export interface TagUpdateManyWithoutThreadsInput {
  create?: Maybe<TagCreateWithoutThreadsInput[] | TagCreateWithoutThreadsInput>;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutThreadsInput[]
    | TagUpdateWithWhereUniqueWithoutThreadsInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutThreadsInput[]
    | TagUpsertWithWhereUniqueWithoutThreadsInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueWithoutThreadsInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutThreadsDataInput;
}

export interface TagUpdateWithoutThreadsDataInput {
  name?: Maybe<String>;
  gigs?: Maybe<GigUpdateManyInput>;
  categories?: Maybe<TagCategoryUpdateManyWithoutTagsInput>;
}

export interface GigUpdateManyInput {
  create?: Maybe<GigCreateInput[] | GigCreateInput>;
  update?: Maybe<
    GigUpdateWithWhereUniqueNestedInput[] | GigUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    GigUpsertWithWhereUniqueNestedInput[] | GigUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  connect?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  set?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  disconnect?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  deleteMany?: Maybe<GigScalarWhereInput[] | GigScalarWhereInput>;
  updateMany?: Maybe<
    GigUpdateManyWithWhereNestedInput[] | GigUpdateManyWithWhereNestedInput
  >;
}

export interface GigUpdateWithWhereUniqueNestedInput {
  where: GigWhereUniqueInput;
  data: GigUpdateDataInput;
}

export interface GigUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  technologies?: Maybe<GigUpdatetechnologiesInput>;
  projectType?: Maybe<ProjectType>;
  paymentType?: Maybe<PaymentType>;
  minFee?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  locationRestriction?: Maybe<String>;
  employer?: Maybe<EmployerUpdateOneRequiredWithoutGigsInput>;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface GigUpdatetechnologiesInput {
  set?: Maybe<String[] | String>;
}

export interface EmployerUpdateOneRequiredWithoutGigsInput {
  create?: Maybe<EmployerCreateWithoutGigsInput>;
  update?: Maybe<EmployerUpdateWithoutGigsDataInput>;
  upsert?: Maybe<EmployerUpsertWithoutGigsInput>;
  connect?: Maybe<EmployerWhereUniqueInput>;
}

export interface EmployerUpdateWithoutGigsDataInput {
  displayName?: Maybe<String>;
  employerType?: Maybe<EmployerType>;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  asUser?: Maybe<UserUpdateOneWithoutAsEmployerInput>;
  website?: Maybe<String>;
  avatar?: Maybe<FileUpdateOneInput>;
}

export interface UserUpdateOneWithoutAsEmployerInput {
  create?: Maybe<UserCreateWithoutAsEmployerInput>;
  update?: Maybe<UserUpdateWithoutAsEmployerDataInput>;
  upsert?: Maybe<UserUpsertWithoutAsEmployerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutAsEmployerDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileUpdateOneInput>;
  asFreelancer?: Maybe<FreelancerUpdateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadUpdateManyWithoutPostedByInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostedByInput>;
}

export interface FileUpdateOneInput {
  create?: Maybe<FileCreateInput>;
  update?: Maybe<FileUpdateDataInput>;
  upsert?: Maybe<FileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FileWhereUniqueInput>;
}

export interface FileUpdateDataInput {
  name?: Maybe<String>;
  contentType?: Maybe<String>;
  url?: Maybe<String>;
}

export interface FileUpsertNestedInput {
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface FreelancerUpdateOneWithoutAsUserInput {
  create?: Maybe<FreelancerCreateWithoutAsUserInput>;
  update?: Maybe<FreelancerUpdateWithoutAsUserDataInput>;
  upsert?: Maybe<FreelancerUpsertWithoutAsUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FreelancerWhereUniqueInput>;
}

export interface FreelancerUpdateWithoutAsUserDataInput {
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerUpdateskillsInput>;
  socials?: Maybe<SocialUpdateManyWithoutFreelancerInput>;
  portfolio?: Maybe<PortfolioProjectUpdateManyWithoutFreelancerInput>;
}

export interface FreelancerUpdateskillsInput {
  set?: Maybe<String[] | String>;
}

export interface SocialUpdateManyWithoutFreelancerInput {
  create?: Maybe<
    SocialCreateWithoutFreelancerInput[] | SocialCreateWithoutFreelancerInput
  >;
  delete?: Maybe<SocialWhereUniqueInput[] | SocialWhereUniqueInput>;
  connect?: Maybe<SocialWhereUniqueInput[] | SocialWhereUniqueInput>;
  set?: Maybe<SocialWhereUniqueInput[] | SocialWhereUniqueInput>;
  disconnect?: Maybe<SocialWhereUniqueInput[] | SocialWhereUniqueInput>;
  update?: Maybe<
    | SocialUpdateWithWhereUniqueWithoutFreelancerInput[]
    | SocialUpdateWithWhereUniqueWithoutFreelancerInput
  >;
  upsert?: Maybe<
    | SocialUpsertWithWhereUniqueWithoutFreelancerInput[]
    | SocialUpsertWithWhereUniqueWithoutFreelancerInput
  >;
  deleteMany?: Maybe<SocialScalarWhereInput[] | SocialScalarWhereInput>;
  updateMany?: Maybe<
    | SocialUpdateManyWithWhereNestedInput[]
    | SocialUpdateManyWithWhereNestedInput
  >;
}

export interface SocialUpdateWithWhereUniqueWithoutFreelancerInput {
  where: SocialWhereUniqueInput;
  data: SocialUpdateWithoutFreelancerDataInput;
}

export interface SocialUpdateWithoutFreelancerDataInput {
  type?: Maybe<SocialType>;
  url?: Maybe<String>;
}

export interface SocialUpsertWithWhereUniqueWithoutFreelancerInput {
  where: SocialWhereUniqueInput;
  update: SocialUpdateWithoutFreelancerDataInput;
  create: SocialCreateWithoutFreelancerInput;
}

export interface SocialScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<SocialType>;
  type_not?: Maybe<SocialType>;
  type_in?: Maybe<SocialType[] | SocialType>;
  type_not_in?: Maybe<SocialType[] | SocialType>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<SocialScalarWhereInput[] | SocialScalarWhereInput>;
  OR?: Maybe<SocialScalarWhereInput[] | SocialScalarWhereInput>;
  NOT?: Maybe<SocialScalarWhereInput[] | SocialScalarWhereInput>;
}

export interface SocialUpdateManyWithWhereNestedInput {
  where: SocialScalarWhereInput;
  data: SocialUpdateManyDataInput;
}

export interface SocialUpdateManyDataInput {
  type?: Maybe<SocialType>;
  url?: Maybe<String>;
}

export interface PortfolioProjectUpdateManyWithoutFreelancerInput {
  create?: Maybe<
    | PortfolioProjectCreateWithoutFreelancerInput[]
    | PortfolioProjectCreateWithoutFreelancerInput
  >;
  delete?: Maybe<
    PortfolioProjectWhereUniqueInput[] | PortfolioProjectWhereUniqueInput
  >;
  connect?: Maybe<
    PortfolioProjectWhereUniqueInput[] | PortfolioProjectWhereUniqueInput
  >;
  set?: Maybe<
    PortfolioProjectWhereUniqueInput[] | PortfolioProjectWhereUniqueInput
  >;
  disconnect?: Maybe<
    PortfolioProjectWhereUniqueInput[] | PortfolioProjectWhereUniqueInput
  >;
  update?: Maybe<
    | PortfolioProjectUpdateWithWhereUniqueWithoutFreelancerInput[]
    | PortfolioProjectUpdateWithWhereUniqueWithoutFreelancerInput
  >;
  upsert?: Maybe<
    | PortfolioProjectUpsertWithWhereUniqueWithoutFreelancerInput[]
    | PortfolioProjectUpsertWithWhereUniqueWithoutFreelancerInput
  >;
  deleteMany?: Maybe<
    PortfolioProjectScalarWhereInput[] | PortfolioProjectScalarWhereInput
  >;
  updateMany?: Maybe<
    | PortfolioProjectUpdateManyWithWhereNestedInput[]
    | PortfolioProjectUpdateManyWithWhereNestedInput
  >;
}

export interface PortfolioProjectUpdateWithWhereUniqueWithoutFreelancerInput {
  where: PortfolioProjectWhereUniqueInput;
  data: PortfolioProjectUpdateWithoutFreelancerDataInput;
}

export interface PortfolioProjectUpdateWithoutFreelancerDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  url?: Maybe<String>;
  avatar?: Maybe<FileUpdateOneInput>;
  images?: Maybe<FileUpdateManyInput>;
}

export interface FileUpdateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueNestedInput[]
    | FileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueNestedInput[]
    | FileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface FileUpdateWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  data: FileUpdateDataInput;
}

export interface FileUpsertWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface FileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  contentType?: Maybe<String>;
  contentType_not?: Maybe<String>;
  contentType_in?: Maybe<String[] | String>;
  contentType_not_in?: Maybe<String[] | String>;
  contentType_lt?: Maybe<String>;
  contentType_lte?: Maybe<String>;
  contentType_gt?: Maybe<String>;
  contentType_gte?: Maybe<String>;
  contentType_contains?: Maybe<String>;
  contentType_not_contains?: Maybe<String>;
  contentType_starts_with?: Maybe<String>;
  contentType_not_starts_with?: Maybe<String>;
  contentType_ends_with?: Maybe<String>;
  contentType_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  OR?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  NOT?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface FileUpdateManyDataInput {
  name?: Maybe<String>;
  contentType?: Maybe<String>;
  url?: Maybe<String>;
}

export interface PortfolioProjectUpsertWithWhereUniqueWithoutFreelancerInput {
  where: PortfolioProjectWhereUniqueInput;
  update: PortfolioProjectUpdateWithoutFreelancerDataInput;
  create: PortfolioProjectCreateWithoutFreelancerInput;
}

export interface PortfolioProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PortfolioProjectScalarWhereInput[] | PortfolioProjectScalarWhereInput
  >;
  OR?: Maybe<
    PortfolioProjectScalarWhereInput[] | PortfolioProjectScalarWhereInput
  >;
  NOT?: Maybe<
    PortfolioProjectScalarWhereInput[] | PortfolioProjectScalarWhereInput
  >;
}

export interface PortfolioProjectUpdateManyWithWhereNestedInput {
  where: PortfolioProjectScalarWhereInput;
  data: PortfolioProjectUpdateManyDataInput;
}

export interface PortfolioProjectUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  url?: Maybe<String>;
}

export interface FreelancerUpsertWithoutAsUserInput {
  update: FreelancerUpdateWithoutAsUserDataInput;
  create: FreelancerCreateWithoutAsUserInput;
}

export interface ThreadUpdateManyWithoutPostedByInput {
  create?: Maybe<
    ThreadCreateWithoutPostedByInput[] | ThreadCreateWithoutPostedByInput
  >;
  delete?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  connect?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  set?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  disconnect?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  update?: Maybe<
    | ThreadUpdateWithWhereUniqueWithoutPostedByInput[]
    | ThreadUpdateWithWhereUniqueWithoutPostedByInput
  >;
  upsert?: Maybe<
    | ThreadUpsertWithWhereUniqueWithoutPostedByInput[]
    | ThreadUpsertWithWhereUniqueWithoutPostedByInput
  >;
  deleteMany?: Maybe<ThreadScalarWhereInput[] | ThreadScalarWhereInput>;
  updateMany?: Maybe<
    | ThreadUpdateManyWithWhereNestedInput[]
    | ThreadUpdateManyWithWhereNestedInput
  >;
}

export interface ThreadUpdateWithWhereUniqueWithoutPostedByInput {
  where: ThreadWhereUniqueInput;
  data: ThreadUpdateWithoutPostedByDataInput;
}

export interface ThreadUpdateWithoutPostedByDataInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagUpdateManyWithoutThreadsInput>;
  comments?: Maybe<CommentUpdateManyWithoutThreadInput>;
  votes?: Maybe<ThreadVoteUpdateManyWithoutThreadInput>;
}

export interface CommentUpdateManyWithoutThreadInput {
  create?: Maybe<
    CommentCreateWithoutThreadInput[] | CommentCreateWithoutThreadInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutThreadInput[]
    | CommentUpdateWithWhereUniqueWithoutThreadInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutThreadInput[]
    | CommentUpsertWithWhereUniqueWithoutThreadInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutThreadInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutThreadDataInput;
}

export interface CommentUpdateWithoutThreadDataInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentUpdateManyWithoutParentInput>;
  parent?: Maybe<CommentUpdateOneWithoutChildrenInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<CommentVoteUpdateManyWithoutCommentInput>;
}

export interface CommentUpdateOneWithoutChildrenInput {
  create?: Maybe<CommentCreateWithoutChildrenInput>;
  update?: Maybe<CommentUpdateWithoutChildrenDataInput>;
  upsert?: Maybe<CommentUpsertWithoutChildrenInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface CommentUpdateWithoutChildrenDataInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  parent?: Maybe<CommentUpdateOneWithoutChildrenInput>;
  thread?: Maybe<ThreadUpdateOneRequiredWithoutCommentsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<CommentVoteUpdateManyWithoutCommentInput>;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileUpdateOneInput>;
  asEmployer?: Maybe<EmployerUpdateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerUpdateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadUpdateManyWithoutPostedByInput>;
}

export interface EmployerUpdateOneWithoutAsUserInput {
  create?: Maybe<EmployerCreateWithoutAsUserInput>;
  update?: Maybe<EmployerUpdateWithoutAsUserDataInput>;
  upsert?: Maybe<EmployerUpsertWithoutAsUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EmployerWhereUniqueInput>;
}

export interface EmployerUpdateWithoutAsUserDataInput {
  displayName?: Maybe<String>;
  employerType?: Maybe<EmployerType>;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  gigs?: Maybe<GigUpdateManyWithoutEmployerInput>;
  website?: Maybe<String>;
  avatar?: Maybe<FileUpdateOneInput>;
}

export interface GigUpdateManyWithoutEmployerInput {
  create?: Maybe<
    GigCreateWithoutEmployerInput[] | GigCreateWithoutEmployerInput
  >;
  delete?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  connect?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  set?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  disconnect?: Maybe<GigWhereUniqueInput[] | GigWhereUniqueInput>;
  update?: Maybe<
    | GigUpdateWithWhereUniqueWithoutEmployerInput[]
    | GigUpdateWithWhereUniqueWithoutEmployerInput
  >;
  upsert?: Maybe<
    | GigUpsertWithWhereUniqueWithoutEmployerInput[]
    | GigUpsertWithWhereUniqueWithoutEmployerInput
  >;
  deleteMany?: Maybe<GigScalarWhereInput[] | GigScalarWhereInput>;
  updateMany?: Maybe<
    GigUpdateManyWithWhereNestedInput[] | GigUpdateManyWithWhereNestedInput
  >;
}

export interface GigUpdateWithWhereUniqueWithoutEmployerInput {
  where: GigWhereUniqueInput;
  data: GigUpdateWithoutEmployerDataInput;
}

export interface GigUpdateWithoutEmployerDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  technologies?: Maybe<GigUpdatetechnologiesInput>;
  projectType?: Maybe<ProjectType>;
  paymentType?: Maybe<PaymentType>;
  minFee?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  locationRestriction?: Maybe<String>;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface GigUpsertWithWhereUniqueWithoutEmployerInput {
  where: GigWhereUniqueInput;
  update: GigUpdateWithoutEmployerDataInput;
  create: GigCreateWithoutEmployerInput;
}

export interface GigScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  projectType?: Maybe<ProjectType>;
  projectType_not?: Maybe<ProjectType>;
  projectType_in?: Maybe<ProjectType[] | ProjectType>;
  projectType_not_in?: Maybe<ProjectType[] | ProjectType>;
  paymentType?: Maybe<PaymentType>;
  paymentType_not?: Maybe<PaymentType>;
  paymentType_in?: Maybe<PaymentType[] | PaymentType>;
  paymentType_not_in?: Maybe<PaymentType[] | PaymentType>;
  minFee?: Maybe<Float>;
  minFee_not?: Maybe<Float>;
  minFee_in?: Maybe<Float[] | Float>;
  minFee_not_in?: Maybe<Float[] | Float>;
  minFee_lt?: Maybe<Float>;
  minFee_lte?: Maybe<Float>;
  minFee_gt?: Maybe<Float>;
  minFee_gte?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  maxFee_not?: Maybe<Float>;
  maxFee_in?: Maybe<Float[] | Float>;
  maxFee_not_in?: Maybe<Float[] | Float>;
  maxFee_lt?: Maybe<Float>;
  maxFee_lte?: Maybe<Float>;
  maxFee_gt?: Maybe<Float>;
  maxFee_gte?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  jobType_not?: Maybe<JobType>;
  jobType_in?: Maybe<JobType[] | JobType>;
  jobType_not_in?: Maybe<JobType[] | JobType>;
  locationRestriction?: Maybe<String>;
  locationRestriction_not?: Maybe<String>;
  locationRestriction_in?: Maybe<String[] | String>;
  locationRestriction_not_in?: Maybe<String[] | String>;
  locationRestriction_lt?: Maybe<String>;
  locationRestriction_lte?: Maybe<String>;
  locationRestriction_gt?: Maybe<String>;
  locationRestriction_gte?: Maybe<String>;
  locationRestriction_contains?: Maybe<String>;
  locationRestriction_not_contains?: Maybe<String>;
  locationRestriction_starts_with?: Maybe<String>;
  locationRestriction_not_starts_with?: Maybe<String>;
  locationRestriction_ends_with?: Maybe<String>;
  locationRestriction_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<GigStatus>;
  status_not?: Maybe<GigStatus>;
  status_in?: Maybe<GigStatus[] | GigStatus>;
  status_not_in?: Maybe<GigStatus[] | GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationType_not?: Maybe<GigCommunicationType>;
  communicationType_in?: Maybe<GigCommunicationType[] | GigCommunicationType>;
  communicationType_not_in?: Maybe<
    GigCommunicationType[] | GigCommunicationType
  >;
  communicationEmail?: Maybe<String>;
  communicationEmail_not?: Maybe<String>;
  communicationEmail_in?: Maybe<String[] | String>;
  communicationEmail_not_in?: Maybe<String[] | String>;
  communicationEmail_lt?: Maybe<String>;
  communicationEmail_lte?: Maybe<String>;
  communicationEmail_gt?: Maybe<String>;
  communicationEmail_gte?: Maybe<String>;
  communicationEmail_contains?: Maybe<String>;
  communicationEmail_not_contains?: Maybe<String>;
  communicationEmail_starts_with?: Maybe<String>;
  communicationEmail_not_starts_with?: Maybe<String>;
  communicationEmail_ends_with?: Maybe<String>;
  communicationEmail_not_ends_with?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
  communicationWebsite_not?: Maybe<String>;
  communicationWebsite_in?: Maybe<String[] | String>;
  communicationWebsite_not_in?: Maybe<String[] | String>;
  communicationWebsite_lt?: Maybe<String>;
  communicationWebsite_lte?: Maybe<String>;
  communicationWebsite_gt?: Maybe<String>;
  communicationWebsite_gte?: Maybe<String>;
  communicationWebsite_contains?: Maybe<String>;
  communicationWebsite_not_contains?: Maybe<String>;
  communicationWebsite_starts_with?: Maybe<String>;
  communicationWebsite_not_starts_with?: Maybe<String>;
  communicationWebsite_ends_with?: Maybe<String>;
  communicationWebsite_not_ends_with?: Maybe<String>;
  AND?: Maybe<GigScalarWhereInput[] | GigScalarWhereInput>;
  OR?: Maybe<GigScalarWhereInput[] | GigScalarWhereInput>;
  NOT?: Maybe<GigScalarWhereInput[] | GigScalarWhereInput>;
}

export interface GigUpdateManyWithWhereNestedInput {
  where: GigScalarWhereInput;
  data: GigUpdateManyDataInput;
}

export interface GigUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  technologies?: Maybe<GigUpdatetechnologiesInput>;
  projectType?: Maybe<ProjectType>;
  paymentType?: Maybe<PaymentType>;
  minFee?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  locationRestriction?: Maybe<String>;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface EmployerUpsertWithoutAsUserInput {
  update: EmployerUpdateWithoutAsUserDataInput;
  create: EmployerCreateWithoutAsUserInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface CommentVoteUpdateManyWithoutCommentInput {
  create?: Maybe<
    | CommentVoteCreateWithoutCommentInput[]
    | CommentVoteCreateWithoutCommentInput
  >;
  delete?: Maybe<CommentVoteWhereUniqueInput[] | CommentVoteWhereUniqueInput>;
  connect?: Maybe<CommentVoteWhereUniqueInput[] | CommentVoteWhereUniqueInput>;
  set?: Maybe<CommentVoteWhereUniqueInput[] | CommentVoteWhereUniqueInput>;
  disconnect?: Maybe<
    CommentVoteWhereUniqueInput[] | CommentVoteWhereUniqueInput
  >;
  update?: Maybe<
    | CommentVoteUpdateWithWhereUniqueWithoutCommentInput[]
    | CommentVoteUpdateWithWhereUniqueWithoutCommentInput
  >;
  upsert?: Maybe<
    | CommentVoteUpsertWithWhereUniqueWithoutCommentInput[]
    | CommentVoteUpsertWithWhereUniqueWithoutCommentInput
  >;
  deleteMany?: Maybe<
    CommentVoteScalarWhereInput[] | CommentVoteScalarWhereInput
  >;
  updateMany?: Maybe<
    | CommentVoteUpdateManyWithWhereNestedInput[]
    | CommentVoteUpdateManyWithWhereNestedInput
  >;
}

export interface CommentVoteUpdateWithWhereUniqueWithoutCommentInput {
  where: CommentVoteWhereUniqueInput;
  data: CommentVoteUpdateWithoutCommentDataInput;
}

export interface CommentVoteUpdateWithoutCommentDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  value?: Maybe<Int>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileUpdateOneInput>;
  asEmployer?: Maybe<EmployerUpdateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerUpdateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadUpdateManyWithoutPostedByInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostedByInput>;
}

export interface CommentUpdateManyWithoutPostedByInput {
  create?: Maybe<
    CommentCreateWithoutPostedByInput[] | CommentCreateWithoutPostedByInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutPostedByInput[]
    | CommentUpdateWithWhereUniqueWithoutPostedByInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutPostedByInput[]
    | CommentUpsertWithWhereUniqueWithoutPostedByInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutPostedByInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostedByDataInput;
}

export interface CommentUpdateWithoutPostedByDataInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentUpdateManyWithoutParentInput>;
  parent?: Maybe<CommentUpdateOneWithoutChildrenInput>;
  thread?: Maybe<ThreadUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<CommentVoteUpdateManyWithoutCommentInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutPostedByInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostedByDataInput;
  create: CommentCreateWithoutPostedByInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isRoot_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  upvoteCount_not?: Maybe<Int>;
  upvoteCount_in?: Maybe<Int[] | Int>;
  upvoteCount_not_in?: Maybe<Int[] | Int>;
  upvoteCount_lt?: Maybe<Int>;
  upvoteCount_lte?: Maybe<Int>;
  upvoteCount_gt?: Maybe<Int>;
  upvoteCount_gte?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  downvoteCount_not?: Maybe<Int>;
  downvoteCount_in?: Maybe<Int[] | Int>;
  downvoteCount_not_in?: Maybe<Int[] | Int>;
  downvoteCount_lt?: Maybe<Int>;
  downvoteCount_lte?: Maybe<Int>;
  downvoteCount_gt?: Maybe<Int>;
  downvoteCount_gte?: Maybe<Int>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CommentVoteUpsertWithWhereUniqueWithoutCommentInput {
  where: CommentVoteWhereUniqueInput;
  update: CommentVoteUpdateWithoutCommentDataInput;
  create: CommentVoteCreateWithoutCommentInput;
}

export interface CommentVoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  AND?: Maybe<CommentVoteScalarWhereInput[] | CommentVoteScalarWhereInput>;
  OR?: Maybe<CommentVoteScalarWhereInput[] | CommentVoteScalarWhereInput>;
  NOT?: Maybe<CommentVoteScalarWhereInput[] | CommentVoteScalarWhereInput>;
}

export interface CommentVoteUpdateManyWithWhereNestedInput {
  where: CommentVoteScalarWhereInput;
  data: CommentVoteUpdateManyDataInput;
}

export interface CommentVoteUpdateManyDataInput {
  value?: Maybe<Int>;
}

export interface CommentUpsertWithoutChildrenInput {
  update: CommentUpdateWithoutChildrenDataInput;
  create: CommentCreateWithoutChildrenInput;
}

export interface CommentUpsertWithWhereUniqueWithoutThreadInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutThreadDataInput;
  create: CommentCreateWithoutThreadInput;
}

export interface ThreadVoteUpdateManyWithoutThreadInput {
  create?: Maybe<
    ThreadVoteCreateWithoutThreadInput[] | ThreadVoteCreateWithoutThreadInput
  >;
  delete?: Maybe<ThreadVoteWhereUniqueInput[] | ThreadVoteWhereUniqueInput>;
  connect?: Maybe<ThreadVoteWhereUniqueInput[] | ThreadVoteWhereUniqueInput>;
  set?: Maybe<ThreadVoteWhereUniqueInput[] | ThreadVoteWhereUniqueInput>;
  disconnect?: Maybe<ThreadVoteWhereUniqueInput[] | ThreadVoteWhereUniqueInput>;
  update?: Maybe<
    | ThreadVoteUpdateWithWhereUniqueWithoutThreadInput[]
    | ThreadVoteUpdateWithWhereUniqueWithoutThreadInput
  >;
  upsert?: Maybe<
    | ThreadVoteUpsertWithWhereUniqueWithoutThreadInput[]
    | ThreadVoteUpsertWithWhereUniqueWithoutThreadInput
  >;
  deleteMany?: Maybe<ThreadVoteScalarWhereInput[] | ThreadVoteScalarWhereInput>;
  updateMany?: Maybe<
    | ThreadVoteUpdateManyWithWhereNestedInput[]
    | ThreadVoteUpdateManyWithWhereNestedInput
  >;
}

export interface ThreadVoteUpdateWithWhereUniqueWithoutThreadInput {
  where: ThreadVoteWhereUniqueInput;
  data: ThreadVoteUpdateWithoutThreadDataInput;
}

export interface ThreadVoteUpdateWithoutThreadDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  value?: Maybe<Int>;
}

export interface ThreadVoteUpsertWithWhereUniqueWithoutThreadInput {
  where: ThreadVoteWhereUniqueInput;
  update: ThreadVoteUpdateWithoutThreadDataInput;
  create: ThreadVoteCreateWithoutThreadInput;
}

export interface ThreadVoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  AND?: Maybe<ThreadVoteScalarWhereInput[] | ThreadVoteScalarWhereInput>;
  OR?: Maybe<ThreadVoteScalarWhereInput[] | ThreadVoteScalarWhereInput>;
  NOT?: Maybe<ThreadVoteScalarWhereInput[] | ThreadVoteScalarWhereInput>;
}

export interface ThreadVoteUpdateManyWithWhereNestedInput {
  where: ThreadVoteScalarWhereInput;
  data: ThreadVoteUpdateManyDataInput;
}

export interface ThreadVoteUpdateManyDataInput {
  value?: Maybe<Int>;
}

export interface ThreadUpsertWithWhereUniqueWithoutPostedByInput {
  where: ThreadWhereUniqueInput;
  update: ThreadUpdateWithoutPostedByDataInput;
  create: ThreadCreateWithoutPostedByInput;
}

export interface ThreadScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  upvoteCount_not?: Maybe<Int>;
  upvoteCount_in?: Maybe<Int[] | Int>;
  upvoteCount_not_in?: Maybe<Int[] | Int>;
  upvoteCount_lt?: Maybe<Int>;
  upvoteCount_lte?: Maybe<Int>;
  upvoteCount_gt?: Maybe<Int>;
  upvoteCount_gte?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  downvoteCount_not?: Maybe<Int>;
  downvoteCount_in?: Maybe<Int[] | Int>;
  downvoteCount_not_in?: Maybe<Int[] | Int>;
  downvoteCount_lt?: Maybe<Int>;
  downvoteCount_lte?: Maybe<Int>;
  downvoteCount_gt?: Maybe<Int>;
  downvoteCount_gte?: Maybe<Int>;
  AND?: Maybe<ThreadScalarWhereInput[] | ThreadScalarWhereInput>;
  OR?: Maybe<ThreadScalarWhereInput[] | ThreadScalarWhereInput>;
  NOT?: Maybe<ThreadScalarWhereInput[] | ThreadScalarWhereInput>;
}

export interface ThreadUpdateManyWithWhereNestedInput {
  where: ThreadScalarWhereInput;
  data: ThreadUpdateManyDataInput;
}

export interface ThreadUpdateManyDataInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
}

export interface UserUpsertWithoutAsEmployerInput {
  update: UserUpdateWithoutAsEmployerDataInput;
  create: UserCreateWithoutAsEmployerInput;
}

export interface EmployerUpsertWithoutGigsInput {
  update: EmployerUpdateWithoutGigsDataInput;
  create: EmployerCreateWithoutGigsInput;
}

export interface GigUpsertWithWhereUniqueNestedInput {
  where: GigWhereUniqueInput;
  update: GigUpdateDataInput;
  create: GigCreateInput;
}

export interface TagCategoryUpdateManyWithoutTagsInput {
  create?: Maybe<
    TagCategoryCreateWithoutTagsInput[] | TagCategoryCreateWithoutTagsInput
  >;
  delete?: Maybe<TagCategoryWhereUniqueInput[] | TagCategoryWhereUniqueInput>;
  connect?: Maybe<TagCategoryWhereUniqueInput[] | TagCategoryWhereUniqueInput>;
  set?: Maybe<TagCategoryWhereUniqueInput[] | TagCategoryWhereUniqueInput>;
  disconnect?: Maybe<
    TagCategoryWhereUniqueInput[] | TagCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | TagCategoryUpdateWithWhereUniqueWithoutTagsInput[]
    | TagCategoryUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | TagCategoryUpsertWithWhereUniqueWithoutTagsInput[]
    | TagCategoryUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<
    TagCategoryScalarWhereInput[] | TagCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | TagCategoryUpdateManyWithWhereNestedInput[]
    | TagCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface TagCategoryUpdateWithWhereUniqueWithoutTagsInput {
  where: TagCategoryWhereUniqueInput;
  data: TagCategoryUpdateWithoutTagsDataInput;
}

export interface TagCategoryUpdateWithoutTagsDataInput {
  name?: Maybe<String>;
}

export interface TagCategoryUpsertWithWhereUniqueWithoutTagsInput {
  where: TagCategoryWhereUniqueInput;
  update: TagCategoryUpdateWithoutTagsDataInput;
  create: TagCategoryCreateWithoutTagsInput;
}

export interface TagCategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TagCategoryScalarWhereInput[] | TagCategoryScalarWhereInput>;
  OR?: Maybe<TagCategoryScalarWhereInput[] | TagCategoryScalarWhereInput>;
  NOT?: Maybe<TagCategoryScalarWhereInput[] | TagCategoryScalarWhereInput>;
}

export interface TagCategoryUpdateManyWithWhereNestedInput {
  where: TagCategoryScalarWhereInput;
  data: TagCategoryUpdateManyDataInput;
}

export interface TagCategoryUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TagUpsertWithWhereUniqueWithoutThreadsInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutThreadsDataInput;
  create: TagCreateWithoutThreadsInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutThreadsInput {
  create?: Maybe<UserCreateWithoutThreadsInput>;
  update?: Maybe<UserUpdateWithoutThreadsDataInput>;
  upsert?: Maybe<UserUpsertWithoutThreadsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutThreadsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileUpdateOneInput>;
  asEmployer?: Maybe<EmployerUpdateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerUpdateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  comments?: Maybe<CommentUpdateManyWithoutPostedByInput>;
}

export interface UserUpsertWithoutThreadsInput {
  update: UserUpdateWithoutThreadsDataInput;
  create: UserCreateWithoutThreadsInput;
}

export interface ThreadUpsertWithoutCommentsInput {
  update: ThreadUpdateWithoutCommentsDataInput;
  create: ThreadCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutParentInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutParentDataInput;
  create: CommentCreateWithoutParentInput;
}

export interface CommentUpdateManyMutationInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
}

export interface CommentVoteCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  value: Int;
  comment: CommentCreateOneWithoutVotesInput;
}

export interface CommentCreateOneWithoutVotesInput {
  create?: Maybe<CommentCreateWithoutVotesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  text: String;
  isRoot: Boolean;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentCreateManyWithoutParentInput>;
  parent?: Maybe<CommentCreateOneWithoutChildrenInput>;
  thread: ThreadCreateOneWithoutCommentsInput;
  postedBy: UserCreateOneWithoutCommentsInput;
}

export interface CommentVoteUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  value?: Maybe<Int>;
  comment?: Maybe<CommentUpdateOneRequiredWithoutVotesInput>;
}

export interface CommentUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<CommentCreateWithoutVotesInput>;
  update?: Maybe<CommentUpdateWithoutVotesDataInput>;
  upsert?: Maybe<CommentUpsertWithoutVotesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface CommentUpdateWithoutVotesDataInput {
  text?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  children?: Maybe<CommentUpdateManyWithoutParentInput>;
  parent?: Maybe<CommentUpdateOneWithoutChildrenInput>;
  thread?: Maybe<ThreadUpdateOneRequiredWithoutCommentsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
}

export interface CommentUpsertWithoutVotesInput {
  update: CommentUpdateWithoutVotesDataInput;
  create: CommentCreateWithoutVotesInput;
}

export interface CommentVoteUpdateManyMutationInput {
  value?: Maybe<Int>;
}

export interface EmployerCreateInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  employerType: EmployerType;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  asUser?: Maybe<UserCreateOneWithoutAsEmployerInput>;
  gigs?: Maybe<GigCreateManyWithoutEmployerInput>;
  website?: Maybe<String>;
  avatar?: Maybe<FileCreateOneInput>;
}

export interface EmployerUpdateInput {
  displayName?: Maybe<String>;
  employerType?: Maybe<EmployerType>;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  asUser?: Maybe<UserUpdateOneWithoutAsEmployerInput>;
  gigs?: Maybe<GigUpdateManyWithoutEmployerInput>;
  website?: Maybe<String>;
  avatar?: Maybe<FileUpdateOneInput>;
}

export interface EmployerUpdateManyMutationInput {
  displayName?: Maybe<String>;
  employerType?: Maybe<EmployerType>;
  introduction?: Maybe<String>;
  email?: Maybe<String>;
  website?: Maybe<String>;
}

export interface FileUpdateInput {
  name?: Maybe<String>;
  contentType?: Maybe<String>;
  url?: Maybe<String>;
}

export interface FileUpdateManyMutationInput {
  name?: Maybe<String>;
  contentType?: Maybe<String>;
  url?: Maybe<String>;
}

export interface FreelancerCreateInput {
  id?: Maybe<ID_Input>;
  asUser?: Maybe<UserCreateOneWithoutAsFreelancerInput>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerCreateskillsInput>;
  socials?: Maybe<SocialCreateManyWithoutFreelancerInput>;
  portfolio?: Maybe<PortfolioProjectCreateManyWithoutFreelancerInput>;
}

export interface UserCreateOneWithoutAsFreelancerInput {
  create?: Maybe<UserCreateWithoutAsFreelancerInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutAsFreelancerInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email: String;
  password: String;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileCreateOneInput>;
  asEmployer?: Maybe<EmployerCreateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadCreateManyWithoutPostedByInput>;
  comments?: Maybe<CommentCreateManyWithoutPostedByInput>;
}

export interface FreelancerUpdateInput {
  asUser?: Maybe<UserUpdateOneWithoutAsFreelancerInput>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerUpdateskillsInput>;
  socials?: Maybe<SocialUpdateManyWithoutFreelancerInput>;
  portfolio?: Maybe<PortfolioProjectUpdateManyWithoutFreelancerInput>;
}

export interface UserUpdateOneWithoutAsFreelancerInput {
  create?: Maybe<UserCreateWithoutAsFreelancerInput>;
  update?: Maybe<UserUpdateWithoutAsFreelancerDataInput>;
  upsert?: Maybe<UserUpsertWithoutAsFreelancerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutAsFreelancerDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileUpdateOneInput>;
  asEmployer?: Maybe<EmployerUpdateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadUpdateManyWithoutPostedByInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostedByInput>;
}

export interface UserUpsertWithoutAsFreelancerInput {
  update: UserUpdateWithoutAsFreelancerDataInput;
  create: UserCreateWithoutAsFreelancerInput;
}

export interface FreelancerUpdateManyMutationInput {
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerUpdateskillsInput>;
}

export interface GigUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  technologies?: Maybe<GigUpdatetechnologiesInput>;
  projectType?: Maybe<ProjectType>;
  paymentType?: Maybe<PaymentType>;
  minFee?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  locationRestriction?: Maybe<String>;
  employer?: Maybe<EmployerUpdateOneRequiredWithoutGigsInput>;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface GigUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  technologies?: Maybe<GigUpdatetechnologiesInput>;
  projectType?: Maybe<ProjectType>;
  paymentType?: Maybe<PaymentType>;
  minFee?: Maybe<Float>;
  maxFee?: Maybe<Float>;
  jobType?: Maybe<JobType>;
  locationRestriction?: Maybe<String>;
  status?: Maybe<GigStatus>;
  communicationType?: Maybe<GigCommunicationType>;
  communicationEmail?: Maybe<String>;
  communicationWebsite?: Maybe<String>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  payer: UserCreateOneInput;
  serviceRefId: String;
  service: PaymentService;
  status: PaymentStatus;
  cost: Float;
}

export interface OrderUpdateInput {
  payer?: Maybe<UserUpdateOneRequiredInput>;
  serviceRefId?: Maybe<String>;
  service?: Maybe<PaymentService>;
  status?: Maybe<PaymentStatus>;
  cost?: Maybe<Float>;
}

export interface OrderUpdateManyMutationInput {
  serviceRefId?: Maybe<String>;
  service?: Maybe<PaymentService>;
  status?: Maybe<PaymentStatus>;
  cost?: Maybe<Float>;
}

export interface PlanCreateInput {
  id?: Maybe<ID_Input>;
  codename: String;
  serviceId: String;
  status: PlanStatus;
  cyclePrice: Float;
  description?: Maybe<String>;
}

export interface PlanUpdateInput {
  codename?: Maybe<String>;
  serviceId?: Maybe<String>;
  status?: Maybe<PlanStatus>;
  cyclePrice?: Maybe<Float>;
  description?: Maybe<String>;
}

export interface PlanUpdateManyMutationInput {
  codename?: Maybe<String>;
  serviceId?: Maybe<String>;
  status?: Maybe<PlanStatus>;
  cyclePrice?: Maybe<Float>;
  description?: Maybe<String>;
}

export interface PlanSubscriptionCreateInput {
  id?: Maybe<ID_Input>;
  subscriber: UserCreateOneInput;
  serviceId: String;
  service: PaymentService;
  status: SubscriptionStatus;
  gig: GigCreateOneInput;
  plan: PlanCreateOneInput;
}

export interface GigCreateOneInput {
  create?: Maybe<GigCreateInput>;
  connect?: Maybe<GigWhereUniqueInput>;
}

export interface PlanCreateOneInput {
  create?: Maybe<PlanCreateInput>;
  connect?: Maybe<PlanWhereUniqueInput>;
}

export interface PlanSubscriptionUpdateInput {
  subscriber?: Maybe<UserUpdateOneRequiredInput>;
  serviceId?: Maybe<String>;
  service?: Maybe<PaymentService>;
  status?: Maybe<SubscriptionStatus>;
  gig?: Maybe<GigUpdateOneRequiredInput>;
  plan?: Maybe<PlanUpdateOneRequiredInput>;
}

export interface GigUpdateOneRequiredInput {
  create?: Maybe<GigCreateInput>;
  update?: Maybe<GigUpdateDataInput>;
  upsert?: Maybe<GigUpsertNestedInput>;
  connect?: Maybe<GigWhereUniqueInput>;
}

export interface GigUpsertNestedInput {
  update: GigUpdateDataInput;
  create: GigCreateInput;
}

export interface PlanUpdateOneRequiredInput {
  create?: Maybe<PlanCreateInput>;
  update?: Maybe<PlanUpdateDataInput>;
  upsert?: Maybe<PlanUpsertNestedInput>;
  connect?: Maybe<PlanWhereUniqueInput>;
}

export interface PlanUpdateDataInput {
  codename?: Maybe<String>;
  serviceId?: Maybe<String>;
  status?: Maybe<PlanStatus>;
  cyclePrice?: Maybe<Float>;
  description?: Maybe<String>;
}

export interface PlanUpsertNestedInput {
  update: PlanUpdateDataInput;
  create: PlanCreateInput;
}

export interface PlanSubscriptionUpdateManyMutationInput {
  serviceId?: Maybe<String>;
  service?: Maybe<PaymentService>;
  status?: Maybe<SubscriptionStatus>;
}

export interface PortfolioProjectCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  url?: Maybe<String>;
  avatar?: Maybe<FileCreateOneInput>;
  images?: Maybe<FileCreateManyInput>;
  freelancer: FreelancerCreateOneWithoutPortfolioInput;
}

export interface FreelancerCreateOneWithoutPortfolioInput {
  create?: Maybe<FreelancerCreateWithoutPortfolioInput>;
  connect?: Maybe<FreelancerWhereUniqueInput>;
}

export interface FreelancerCreateWithoutPortfolioInput {
  id?: Maybe<ID_Input>;
  asUser?: Maybe<UserCreateOneWithoutAsFreelancerInput>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerCreateskillsInput>;
  socials?: Maybe<SocialCreateManyWithoutFreelancerInput>;
}

export interface PortfolioProjectUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  url?: Maybe<String>;
  avatar?: Maybe<FileUpdateOneInput>;
  images?: Maybe<FileUpdateManyInput>;
  freelancer?: Maybe<FreelancerUpdateOneRequiredWithoutPortfolioInput>;
}

export interface FreelancerUpdateOneRequiredWithoutPortfolioInput {
  create?: Maybe<FreelancerCreateWithoutPortfolioInput>;
  update?: Maybe<FreelancerUpdateWithoutPortfolioDataInput>;
  upsert?: Maybe<FreelancerUpsertWithoutPortfolioInput>;
  connect?: Maybe<FreelancerWhereUniqueInput>;
}

export interface FreelancerUpdateWithoutPortfolioDataInput {
  asUser?: Maybe<UserUpdateOneWithoutAsFreelancerInput>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerUpdateskillsInput>;
  socials?: Maybe<SocialUpdateManyWithoutFreelancerInput>;
}

export interface FreelancerUpsertWithoutPortfolioInput {
  update: FreelancerUpdateWithoutPortfolioDataInput;
  create: FreelancerCreateWithoutPortfolioInput;
}

export interface PortfolioProjectUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  url?: Maybe<String>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  price: Float;
  codename: String;
  description?: Maybe<String>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  codename?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  codename?: Maybe<String>;
  description?: Maybe<String>;
}

export interface SocialCreateInput {
  id?: Maybe<ID_Input>;
  type: SocialType;
  url: String;
  freelancer: FreelancerCreateOneWithoutSocialsInput;
}

export interface FreelancerCreateOneWithoutSocialsInput {
  create?: Maybe<FreelancerCreateWithoutSocialsInput>;
  connect?: Maybe<FreelancerWhereUniqueInput>;
}

export interface FreelancerCreateWithoutSocialsInput {
  id?: Maybe<ID_Input>;
  asUser?: Maybe<UserCreateOneWithoutAsFreelancerInput>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerCreateskillsInput>;
  portfolio?: Maybe<PortfolioProjectCreateManyWithoutFreelancerInput>;
}

export interface SocialUpdateInput {
  type?: Maybe<SocialType>;
  url?: Maybe<String>;
  freelancer?: Maybe<FreelancerUpdateOneRequiredWithoutSocialsInput>;
}

export interface FreelancerUpdateOneRequiredWithoutSocialsInput {
  create?: Maybe<FreelancerCreateWithoutSocialsInput>;
  update?: Maybe<FreelancerUpdateWithoutSocialsDataInput>;
  upsert?: Maybe<FreelancerUpsertWithoutSocialsInput>;
  connect?: Maybe<FreelancerWhereUniqueInput>;
}

export interface FreelancerUpdateWithoutSocialsDataInput {
  asUser?: Maybe<UserUpdateOneWithoutAsFreelancerInput>;
  bio?: Maybe<String>;
  website?: Maybe<String>;
  location?: Maybe<String>;
  timezone?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isForHire?: Maybe<Boolean>;
  skills?: Maybe<FreelancerUpdateskillsInput>;
  portfolio?: Maybe<PortfolioProjectUpdateManyWithoutFreelancerInput>;
}

export interface FreelancerUpsertWithoutSocialsInput {
  update: FreelancerUpdateWithoutSocialsDataInput;
  create: FreelancerCreateWithoutSocialsInput;
}

export interface SocialUpdateManyMutationInput {
  type?: Maybe<SocialType>;
  url?: Maybe<String>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  threads?: Maybe<ThreadCreateManyWithoutTagsInput>;
  gigs?: Maybe<GigCreateManyInput>;
  categories?: Maybe<TagCategoryCreateManyWithoutTagsInput>;
}

export interface ThreadCreateManyWithoutTagsInput {
  create?: Maybe<ThreadCreateWithoutTagsInput[] | ThreadCreateWithoutTagsInput>;
  connect?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
}

export interface ThreadCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  title: String;
  body: String;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  postedBy: UserCreateOneWithoutThreadsInput;
  comments?: Maybe<CommentCreateManyWithoutThreadInput>;
  votes?: Maybe<ThreadVoteCreateManyWithoutThreadInput>;
}

export interface TagUpdateInput {
  name?: Maybe<String>;
  threads?: Maybe<ThreadUpdateManyWithoutTagsInput>;
  gigs?: Maybe<GigUpdateManyInput>;
  categories?: Maybe<TagCategoryUpdateManyWithoutTagsInput>;
}

export interface ThreadUpdateManyWithoutTagsInput {
  create?: Maybe<ThreadCreateWithoutTagsInput[] | ThreadCreateWithoutTagsInput>;
  delete?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  connect?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  set?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  disconnect?: Maybe<ThreadWhereUniqueInput[] | ThreadWhereUniqueInput>;
  update?: Maybe<
    | ThreadUpdateWithWhereUniqueWithoutTagsInput[]
    | ThreadUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | ThreadUpsertWithWhereUniqueWithoutTagsInput[]
    | ThreadUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<ThreadScalarWhereInput[] | ThreadScalarWhereInput>;
  updateMany?: Maybe<
    | ThreadUpdateManyWithWhereNestedInput[]
    | ThreadUpdateManyWithWhereNestedInput
  >;
}

export interface ThreadUpdateWithWhereUniqueWithoutTagsInput {
  where: ThreadWhereUniqueInput;
  data: ThreadUpdateWithoutTagsDataInput;
}

export interface ThreadUpdateWithoutTagsDataInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutThreadsInput>;
  comments?: Maybe<CommentUpdateManyWithoutThreadInput>;
  votes?: Maybe<ThreadVoteUpdateManyWithoutThreadInput>;
}

export interface ThreadUpsertWithWhereUniqueWithoutTagsInput {
  where: ThreadWhereUniqueInput;
  update: ThreadUpdateWithoutTagsDataInput;
  create: ThreadCreateWithoutTagsInput;
}

export interface TagUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TagCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  tags?: Maybe<TagCreateManyWithoutCategoriesInput>;
}

export interface TagCreateManyWithoutCategoriesInput {
  create?: Maybe<
    TagCreateWithoutCategoriesInput[] | TagCreateWithoutCategoriesInput
  >;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  threads?: Maybe<ThreadCreateManyWithoutTagsInput>;
  gigs?: Maybe<GigCreateManyInput>;
}

export interface TagCategoryUpdateInput {
  name?: Maybe<String>;
  tags?: Maybe<TagUpdateManyWithoutCategoriesInput>;
}

export interface TagUpdateManyWithoutCategoriesInput {
  create?: Maybe<
    TagCreateWithoutCategoriesInput[] | TagCreateWithoutCategoriesInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutCategoriesInput[]
    | TagUpdateWithWhereUniqueWithoutCategoriesInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutCategoriesInput[]
    | TagUpsertWithWhereUniqueWithoutCategoriesInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueWithoutCategoriesInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutCategoriesDataInput;
}

export interface TagUpdateWithoutCategoriesDataInput {
  name?: Maybe<String>;
  threads?: Maybe<ThreadUpdateManyWithoutTagsInput>;
  gigs?: Maybe<GigUpdateManyInput>;
}

export interface TagUpsertWithWhereUniqueWithoutCategoriesInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutCategoriesDataInput;
  create: TagCreateWithoutCategoriesInput;
}

export interface TagCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ThreadCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  body: String;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagCreateManyWithoutThreadsInput>;
  postedBy: UserCreateOneWithoutThreadsInput;
  comments?: Maybe<CommentCreateManyWithoutThreadInput>;
  votes?: Maybe<ThreadVoteCreateManyWithoutThreadInput>;
}

export interface ThreadUpdateInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagUpdateManyWithoutThreadsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutThreadsInput>;
  comments?: Maybe<CommentUpdateManyWithoutThreadInput>;
  votes?: Maybe<ThreadVoteUpdateManyWithoutThreadInput>;
}

export interface ThreadUpdateManyMutationInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
}

export interface ThreadVoteCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  value: Int;
  thread: ThreadCreateOneWithoutVotesInput;
}

export interface ThreadCreateOneWithoutVotesInput {
  create?: Maybe<ThreadCreateWithoutVotesInput>;
  connect?: Maybe<ThreadWhereUniqueInput>;
}

export interface ThreadCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  title: String;
  body: String;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagCreateManyWithoutThreadsInput>;
  postedBy: UserCreateOneWithoutThreadsInput;
  comments?: Maybe<CommentCreateManyWithoutThreadInput>;
}

export interface ThreadVoteUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  value?: Maybe<Int>;
  thread?: Maybe<ThreadUpdateOneRequiredWithoutVotesInput>;
}

export interface ThreadUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<ThreadCreateWithoutVotesInput>;
  update?: Maybe<ThreadUpdateWithoutVotesDataInput>;
  upsert?: Maybe<ThreadUpsertWithoutVotesInput>;
  connect?: Maybe<ThreadWhereUniqueInput>;
}

export interface ThreadUpdateWithoutVotesDataInput {
  title?: Maybe<String>;
  body?: Maybe<String>;
  upvoteCount?: Maybe<Int>;
  downvoteCount?: Maybe<Int>;
  tags?: Maybe<TagUpdateManyWithoutThreadsInput>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutThreadsInput>;
  comments?: Maybe<CommentUpdateManyWithoutThreadInput>;
}

export interface ThreadUpsertWithoutVotesInput {
  update: ThreadUpdateWithoutVotesDataInput;
  create: ThreadCreateWithoutVotesInput;
}

export interface ThreadVoteUpdateManyMutationInput {
  value?: Maybe<Int>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  avatar?: Maybe<FileUpdateOneInput>;
  asEmployer?: Maybe<EmployerUpdateOneWithoutAsUserInput>;
  asFreelancer?: Maybe<FreelancerUpdateOneWithoutAsUserInput>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
  threads?: Maybe<ThreadUpdateManyWithoutPostedByInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostedByInput>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<UserRole>;
  accountType?: Maybe<AccountType>;
  isEmailVerified?: Maybe<Boolean>;
  onboardingStep?: Maybe<OnboardingStep>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface CommentVoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentVoteWhereInput>;
  AND?: Maybe<
    CommentVoteSubscriptionWhereInput[] | CommentVoteSubscriptionWhereInput
  >;
  OR?: Maybe<
    CommentVoteSubscriptionWhereInput[] | CommentVoteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CommentVoteSubscriptionWhereInput[] | CommentVoteSubscriptionWhereInput
  >;
}

export interface EmployerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployerWhereInput>;
  AND?: Maybe<
    EmployerSubscriptionWhereInput[] | EmployerSubscriptionWhereInput
  >;
  OR?: Maybe<EmployerSubscriptionWhereInput[] | EmployerSubscriptionWhereInput>;
  NOT?: Maybe<
    EmployerSubscriptionWhereInput[] | EmployerSubscriptionWhereInput
  >;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface FreelancerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FreelancerWhereInput>;
  AND?: Maybe<
    FreelancerSubscriptionWhereInput[] | FreelancerSubscriptionWhereInput
  >;
  OR?: Maybe<
    FreelancerSubscriptionWhereInput[] | FreelancerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FreelancerSubscriptionWhereInput[] | FreelancerSubscriptionWhereInput
  >;
}

export interface GigSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GigWhereInput>;
  AND?: Maybe<GigSubscriptionWhereInput[] | GigSubscriptionWhereInput>;
  OR?: Maybe<GigSubscriptionWhereInput[] | GigSubscriptionWhereInput>;
  NOT?: Maybe<GigSubscriptionWhereInput[] | GigSubscriptionWhereInput>;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface PlanSubscriptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlanSubscriptionWhereInput>;
  AND?: Maybe<
    | PlanSubscriptionSubscriptionWhereInput[]
    | PlanSubscriptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PlanSubscriptionSubscriptionWhereInput[]
    | PlanSubscriptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PlanSubscriptionSubscriptionWhereInput[]
    | PlanSubscriptionSubscriptionWhereInput
  >;
}

export interface PortfolioProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PortfolioProjectWhereInput>;
  AND?: Maybe<
    | PortfolioProjectSubscriptionWhereInput[]
    | PortfolioProjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PortfolioProjectSubscriptionWhereInput[]
    | PortfolioProjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PortfolioProjectSubscriptionWhereInput[]
    | PortfolioProjectSubscriptionWhereInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface SocialSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SocialWhereInput>;
  AND?: Maybe<SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput>;
  OR?: Maybe<SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput>;
  NOT?: Maybe<SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput>;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface TagCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagCategoryWhereInput>;
  AND?: Maybe<
    TagCategorySubscriptionWhereInput[] | TagCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    TagCategorySubscriptionWhereInput[] | TagCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    TagCategorySubscriptionWhereInput[] | TagCategorySubscriptionWhereInput
  >;
}

export interface ThreadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ThreadWhereInput>;
  AND?: Maybe<ThreadSubscriptionWhereInput[] | ThreadSubscriptionWhereInput>;
  OR?: Maybe<ThreadSubscriptionWhereInput[] | ThreadSubscriptionWhereInput>;
  NOT?: Maybe<ThreadSubscriptionWhereInput[] | ThreadSubscriptionWhereInput>;
}

export interface ThreadVoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ThreadVoteWhereInput>;
  AND?: Maybe<
    ThreadVoteSubscriptionWhereInput[] | ThreadVoteSubscriptionWhereInput
  >;
  OR?: Maybe<
    ThreadVoteSubscriptionWhereInput[] | ThreadVoteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ThreadVoteSubscriptionWhereInput[] | ThreadVoteSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Comment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
  isRoot: Boolean;
  isDeleted?: Boolean;
  upvoteCount: Int;
  downvoteCount: Int;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  upvoteCount: () => Promise<Int>;
  downvoteCount: () => Promise<Int>;
  children: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = CommentPromise>() => T;
  thread: <T = ThreadPromise>() => T;
  postedBy: <T = UserPromise>() => T;
  votes: <T = FragmentableArray<CommentVote>>(args?: {
    where?: CommentVoteWhereInput;
    orderBy?: CommentVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  upvoteCount: () => Promise<AsyncIterator<Int>>;
  downvoteCount: () => Promise<AsyncIterator<Int>>;
  children: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = CommentSubscription>() => T;
  thread: <T = ThreadSubscription>() => T;
  postedBy: <T = UserSubscription>() => T;
  votes: <T = Promise<AsyncIterator<CommentVoteSubscription>>>(args?: {
    where?: CommentVoteWhereInput;
    orderBy?: CommentVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  upvoteCount: () => Promise<Int>;
  downvoteCount: () => Promise<Int>;
  children: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = CommentPromise>() => T;
  thread: <T = ThreadPromise>() => T;
  postedBy: <T = UserPromise>() => T;
  votes: <T = FragmentableArray<CommentVote>>(args?: {
    where?: CommentVoteWhereInput;
    orderBy?: CommentVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Thread {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  body: String;
  upvoteCount: Int;
  downvoteCount: Int;
}

export interface ThreadPromise extends Promise<Thread>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  body: () => Promise<String>;
  upvoteCount: () => Promise<Int>;
  downvoteCount: () => Promise<Int>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  postedBy: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<ThreadVote>>(args?: {
    where?: ThreadVoteWhereInput;
    orderBy?: ThreadVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ThreadSubscription
  extends Promise<AsyncIterator<Thread>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  upvoteCount: () => Promise<AsyncIterator<Int>>;
  downvoteCount: () => Promise<AsyncIterator<Int>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  postedBy: <T = UserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = Promise<AsyncIterator<ThreadVoteSubscription>>>(args?: {
    where?: ThreadVoteWhereInput;
    orderBy?: ThreadVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ThreadNullablePromise
  extends Promise<Thread | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  body: () => Promise<String>;
  upvoteCount: () => Promise<Int>;
  downvoteCount: () => Promise<Int>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  postedBy: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<ThreadVote>>(args?: {
    where?: ThreadVoteWhereInput;
    orderBy?: ThreadVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Tag {
  id: ID_Output;
  name?: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  threads: <T = FragmentableArray<Thread>>(args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gigs: <T = FragmentableArray<Gig>>(args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<TagCategory>>(args?: {
    where?: TagCategoryWhereInput;
    orderBy?: TagCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  threads: <T = Promise<AsyncIterator<ThreadSubscription>>>(args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gigs: <T = Promise<AsyncIterator<GigSubscription>>>(args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = Promise<AsyncIterator<TagCategorySubscription>>>(args?: {
    where?: TagCategoryWhereInput;
    orderBy?: TagCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  threads: <T = FragmentableArray<Thread>>(args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gigs: <T = FragmentableArray<Gig>>(args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<TagCategory>>(args?: {
    where?: TagCategoryWhereInput;
    orderBy?: TagCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Gig {
  id: ID_Output;
  title: String;
  description: String;
  technologies: String[];
  projectType: ProjectType;
  paymentType: PaymentType;
  minFee: Float;
  maxFee: Float;
  jobType: JobType;
  locationRestriction?: String;
  createdAt: DateTimeOutput;
  status: GigStatus;
  communicationType: GigCommunicationType;
  communicationEmail?: String;
  communicationWebsite?: String;
}

export interface GigPromise extends Promise<Gig>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  technologies: () => Promise<String[]>;
  projectType: () => Promise<ProjectType>;
  paymentType: () => Promise<PaymentType>;
  minFee: () => Promise<Float>;
  maxFee: () => Promise<Float>;
  jobType: () => Promise<JobType>;
  locationRestriction: () => Promise<String>;
  employer: <T = EmployerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<GigStatus>;
  communicationType: () => Promise<GigCommunicationType>;
  communicationEmail: () => Promise<String>;
  communicationWebsite: () => Promise<String>;
}

export interface GigSubscription
  extends Promise<AsyncIterator<Gig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  technologies: () => Promise<AsyncIterator<String[]>>;
  projectType: () => Promise<AsyncIterator<ProjectType>>;
  paymentType: () => Promise<AsyncIterator<PaymentType>>;
  minFee: () => Promise<AsyncIterator<Float>>;
  maxFee: () => Promise<AsyncIterator<Float>>;
  jobType: () => Promise<AsyncIterator<JobType>>;
  locationRestriction: () => Promise<AsyncIterator<String>>;
  employer: <T = EmployerSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<GigStatus>>;
  communicationType: () => Promise<AsyncIterator<GigCommunicationType>>;
  communicationEmail: () => Promise<AsyncIterator<String>>;
  communicationWebsite: () => Promise<AsyncIterator<String>>;
}

export interface GigNullablePromise extends Promise<Gig | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  technologies: () => Promise<String[]>;
  projectType: () => Promise<ProjectType>;
  paymentType: () => Promise<PaymentType>;
  minFee: () => Promise<Float>;
  maxFee: () => Promise<Float>;
  jobType: () => Promise<JobType>;
  locationRestriction: () => Promise<String>;
  employer: <T = EmployerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<GigStatus>;
  communicationType: () => Promise<GigCommunicationType>;
  communicationEmail: () => Promise<String>;
  communicationWebsite: () => Promise<String>;
}

export interface Employer {
  id: ID_Output;
  displayName: String;
  employerType: EmployerType;
  introduction?: String;
  email?: String;
  website?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployerPromise extends Promise<Employer>, Fragmentable {
  id: () => Promise<ID_Output>;
  displayName: () => Promise<String>;
  employerType: () => Promise<EmployerType>;
  introduction: () => Promise<String>;
  email: () => Promise<String>;
  asUser: <T = UserPromise>() => T;
  gigs: <T = FragmentableArray<Gig>>(args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  website: () => Promise<String>;
  avatar: <T = FilePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployerSubscription
  extends Promise<AsyncIterator<Employer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  displayName: () => Promise<AsyncIterator<String>>;
  employerType: () => Promise<AsyncIterator<EmployerType>>;
  introduction: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  asUser: <T = UserSubscription>() => T;
  gigs: <T = Promise<AsyncIterator<GigSubscription>>>(args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  website: () => Promise<AsyncIterator<String>>;
  avatar: <T = FileSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployerNullablePromise
  extends Promise<Employer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  displayName: () => Promise<String>;
  employerType: () => Promise<EmployerType>;
  introduction: () => Promise<String>;
  email: () => Promise<String>;
  asUser: <T = UserPromise>() => T;
  gigs: <T = FragmentableArray<Gig>>(args?: {
    where?: GigWhereInput;
    orderBy?: GigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  website: () => Promise<String>;
  avatar: <T = FilePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email: String;
  password: String;
  role: UserRole;
  accountType?: AccountType;
  createdAt: DateTimeOutput;
  isEmailVerified?: Boolean;
  onboardingStep?: OnboardingStep;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRole>;
  accountType: () => Promise<AccountType>;
  createdAt: () => Promise<DateTimeOutput>;
  avatar: <T = FilePromise>() => T;
  asEmployer: <T = EmployerPromise>() => T;
  asFreelancer: <T = FreelancerPromise>() => T;
  isEmailVerified: () => Promise<Boolean>;
  onboardingStep: () => Promise<OnboardingStep>;
  threads: <T = FragmentableArray<Thread>>(args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  accountType: () => Promise<AsyncIterator<AccountType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: <T = FileSubscription>() => T;
  asEmployer: <T = EmployerSubscription>() => T;
  asFreelancer: <T = FreelancerSubscription>() => T;
  isEmailVerified: () => Promise<AsyncIterator<Boolean>>;
  onboardingStep: () => Promise<AsyncIterator<OnboardingStep>>;
  threads: <T = Promise<AsyncIterator<ThreadSubscription>>>(args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRole>;
  accountType: () => Promise<AccountType>;
  createdAt: () => Promise<DateTimeOutput>;
  avatar: <T = FilePromise>() => T;
  asEmployer: <T = EmployerPromise>() => T;
  asFreelancer: <T = FreelancerPromise>() => T;
  isEmailVerified: () => Promise<Boolean>;
  onboardingStep: () => Promise<OnboardingStep>;
  threads: <T = FragmentableArray<Thread>>(args?: {
    where?: ThreadWhereInput;
    orderBy?: ThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface File {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name?: String;
  contentType?: String;
  url?: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  contentType: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  contentType: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  contentType: () => Promise<String>;
  url: () => Promise<String>;
}

export interface Freelancer {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  website?: String;
  location?: String;
  timezone?: String;
  isPrivate?: Boolean;
  isForHire?: Boolean;
  skills: String[];
}

export interface FreelancerPromise extends Promise<Freelancer>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  asUser: <T = UserPromise>() => T;
  bio: () => Promise<String>;
  website: () => Promise<String>;
  location: () => Promise<String>;
  timezone: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  isForHire: () => Promise<Boolean>;
  skills: () => Promise<String[]>;
  socials: <T = FragmentableArray<Social>>(args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  portfolio: <T = FragmentableArray<PortfolioProject>>(args?: {
    where?: PortfolioProjectWhereInput;
    orderBy?: PortfolioProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FreelancerSubscription
  extends Promise<AsyncIterator<Freelancer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  asUser: <T = UserSubscription>() => T;
  bio: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  timezone: () => Promise<AsyncIterator<String>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  isForHire: () => Promise<AsyncIterator<Boolean>>;
  skills: () => Promise<AsyncIterator<String[]>>;
  socials: <T = Promise<AsyncIterator<SocialSubscription>>>(args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  portfolio: <T = Promise<AsyncIterator<PortfolioProjectSubscription>>>(args?: {
    where?: PortfolioProjectWhereInput;
    orderBy?: PortfolioProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FreelancerNullablePromise
  extends Promise<Freelancer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  asUser: <T = UserPromise>() => T;
  bio: () => Promise<String>;
  website: () => Promise<String>;
  location: () => Promise<String>;
  timezone: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  isForHire: () => Promise<Boolean>;
  skills: () => Promise<String[]>;
  socials: <T = FragmentableArray<Social>>(args?: {
    where?: SocialWhereInput;
    orderBy?: SocialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  portfolio: <T = FragmentableArray<PortfolioProject>>(args?: {
    where?: PortfolioProjectWhereInput;
    orderBy?: PortfolioProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Social {
  id: ID_Output;
  type: SocialType;
  url: String;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<SocialType>;
  url: () => Promise<String>;
  freelancer: <T = FreelancerPromise>() => T;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<SocialType>>;
  url: () => Promise<AsyncIterator<String>>;
  freelancer: <T = FreelancerSubscription>() => T;
}

export interface SocialNullablePromise
  extends Promise<Social | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<SocialType>;
  url: () => Promise<String>;
  freelancer: <T = FreelancerPromise>() => T;
}

export interface PortfolioProject {
  id: ID_Output;
  title: String;
  description: String;
  url?: String;
}

export interface PortfolioProjectPromise
  extends Promise<PortfolioProject>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  avatar: <T = FilePromise>() => T;
  images: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  freelancer: <T = FreelancerPromise>() => T;
}

export interface PortfolioProjectSubscription
  extends Promise<AsyncIterator<PortfolioProject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  avatar: <T = FileSubscription>() => T;
  images: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  freelancer: <T = FreelancerSubscription>() => T;
}

export interface PortfolioProjectNullablePromise
  extends Promise<PortfolioProject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  avatar: <T = FilePromise>() => T;
  images: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  freelancer: <T = FreelancerPromise>() => T;
}

export interface TagCategory {
  id: ID_Output;
  name?: String;
}

export interface TagCategoryPromise extends Promise<TagCategory>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagCategorySubscription
  extends Promise<AsyncIterator<TagCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagCategoryNullablePromise
  extends Promise<TagCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ThreadVote {
  id: ID_Output;
  createdAt: DateTimeOutput;
  value: Int;
}

export interface ThreadVotePromise extends Promise<ThreadVote>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  value: () => Promise<Int>;
  thread: <T = ThreadPromise>() => T;
}

export interface ThreadVoteSubscription
  extends Promise<AsyncIterator<ThreadVote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  value: () => Promise<AsyncIterator<Int>>;
  thread: <T = ThreadSubscription>() => T;
}

export interface ThreadVoteNullablePromise
  extends Promise<ThreadVote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  value: () => Promise<Int>;
  thread: <T = ThreadPromise>() => T;
}

export interface CommentVote {
  id: ID_Output;
  createdAt: DateTimeOutput;
  value: Int;
}

export interface CommentVotePromise extends Promise<CommentVote>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  value: () => Promise<Int>;
  comment: <T = CommentPromise>() => T;
}

export interface CommentVoteSubscription
  extends Promise<AsyncIterator<CommentVote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  value: () => Promise<AsyncIterator<Int>>;
  comment: <T = CommentSubscription>() => T;
}

export interface CommentVoteNullablePromise
  extends Promise<CommentVote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  value: () => Promise<Int>;
  comment: <T = CommentPromise>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentVoteConnection {
  pageInfo: PageInfo;
  edges: CommentVoteEdge[];
}

export interface CommentVoteConnectionPromise
  extends Promise<CommentVoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentVoteEdge>>() => T;
  aggregate: <T = AggregateCommentVotePromise>() => T;
}

export interface CommentVoteConnectionSubscription
  extends Promise<AsyncIterator<CommentVoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentVoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentVoteSubscription>() => T;
}

export interface CommentVoteEdge {
  node: CommentVote;
  cursor: String;
}

export interface CommentVoteEdgePromise
  extends Promise<CommentVoteEdge>,
    Fragmentable {
  node: <T = CommentVotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentVoteEdgeSubscription
  extends Promise<AsyncIterator<CommentVoteEdge>>,
    Fragmentable {
  node: <T = CommentVoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommentVote {
  count: Int;
}

export interface AggregateCommentVotePromise
  extends Promise<AggregateCommentVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentVoteSubscription
  extends Promise<AsyncIterator<AggregateCommentVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployerConnection {
  pageInfo: PageInfo;
  edges: EmployerEdge[];
}

export interface EmployerConnectionPromise
  extends Promise<EmployerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployerEdge>>() => T;
  aggregate: <T = AggregateEmployerPromise>() => T;
}

export interface EmployerConnectionSubscription
  extends Promise<AsyncIterator<EmployerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployerSubscription>() => T;
}

export interface EmployerEdge {
  node: Employer;
  cursor: String;
}

export interface EmployerEdgePromise
  extends Promise<EmployerEdge>,
    Fragmentable {
  node: <T = EmployerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployerEdgeSubscription
  extends Promise<AsyncIterator<EmployerEdge>>,
    Fragmentable {
  node: <T = EmployerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployer {
  count: Int;
}

export interface AggregateEmployerPromise
  extends Promise<AggregateEmployer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployerSubscription
  extends Promise<AsyncIterator<AggregateEmployer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FreelancerConnection {
  pageInfo: PageInfo;
  edges: FreelancerEdge[];
}

export interface FreelancerConnectionPromise
  extends Promise<FreelancerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FreelancerEdge>>() => T;
  aggregate: <T = AggregateFreelancerPromise>() => T;
}

export interface FreelancerConnectionSubscription
  extends Promise<AsyncIterator<FreelancerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FreelancerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFreelancerSubscription>() => T;
}

export interface FreelancerEdge {
  node: Freelancer;
  cursor: String;
}

export interface FreelancerEdgePromise
  extends Promise<FreelancerEdge>,
    Fragmentable {
  node: <T = FreelancerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FreelancerEdgeSubscription
  extends Promise<AsyncIterator<FreelancerEdge>>,
    Fragmentable {
  node: <T = FreelancerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFreelancer {
  count: Int;
}

export interface AggregateFreelancerPromise
  extends Promise<AggregateFreelancer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFreelancerSubscription
  extends Promise<AsyncIterator<AggregateFreelancer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GigConnection {
  pageInfo: PageInfo;
  edges: GigEdge[];
}

export interface GigConnectionPromise
  extends Promise<GigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GigEdge>>() => T;
  aggregate: <T = AggregateGigPromise>() => T;
}

export interface GigConnectionSubscription
  extends Promise<AsyncIterator<GigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GigEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGigSubscription>() => T;
}

export interface GigEdge {
  node: Gig;
  cursor: String;
}

export interface GigEdgePromise extends Promise<GigEdge>, Fragmentable {
  node: <T = GigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GigEdgeSubscription
  extends Promise<AsyncIterator<GigEdge>>,
    Fragmentable {
  node: <T = GigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGig {
  count: Int;
}

export interface AggregateGigPromise
  extends Promise<AggregateGig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGigSubscription
  extends Promise<AsyncIterator<AggregateGig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Order {
  id: ID_Output;
  serviceRefId: String;
  service: PaymentService;
  status: PaymentStatus;
  cost: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  payer: <T = UserPromise>() => T;
  serviceRefId: () => Promise<String>;
  service: () => Promise<PaymentService>;
  status: () => Promise<PaymentStatus>;
  cost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payer: <T = UserSubscription>() => T;
  serviceRefId: () => Promise<AsyncIterator<String>>;
  service: () => Promise<AsyncIterator<PaymentService>>;
  status: () => Promise<AsyncIterator<PaymentStatus>>;
  cost: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payer: <T = UserPromise>() => T;
  serviceRefId: () => Promise<String>;
  service: () => Promise<PaymentService>;
  status: () => Promise<PaymentStatus>;
  cost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Plan {
  id: ID_Output;
  codename: String;
  serviceId: String;
  status: PlanStatus;
  cyclePrice: Float;
  description?: String;
}

export interface PlanPromise extends Promise<Plan>, Fragmentable {
  id: () => Promise<ID_Output>;
  codename: () => Promise<String>;
  serviceId: () => Promise<String>;
  status: () => Promise<PlanStatus>;
  cyclePrice: () => Promise<Float>;
  description: () => Promise<String>;
}

export interface PlanSubscription
  extends Promise<AsyncIterator<Plan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  codename: () => Promise<AsyncIterator<String>>;
  serviceId: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<PlanStatus>>;
  cyclePrice: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PlanNullablePromise
  extends Promise<Plan | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  codename: () => Promise<String>;
  serviceId: () => Promise<String>;
  status: () => Promise<PlanStatus>;
  cyclePrice: () => Promise<Float>;
  description: () => Promise<String>;
}

export interface PlanConnection {
  pageInfo: PageInfo;
  edges: PlanEdge[];
}

export interface PlanConnectionPromise
  extends Promise<PlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlanEdge>>() => T;
  aggregate: <T = AggregatePlanPromise>() => T;
}

export interface PlanConnectionSubscription
  extends Promise<AsyncIterator<PlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlanSubscription>() => T;
}

export interface PlanEdge {
  node: Plan;
  cursor: String;
}

export interface PlanEdgePromise extends Promise<PlanEdge>, Fragmentable {
  node: <T = PlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlanEdgeSubscription
  extends Promise<AsyncIterator<PlanEdge>>,
    Fragmentable {
  node: <T = PlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlan {
  count: Int;
}

export interface AggregatePlanPromise
  extends Promise<AggregatePlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlanSubscription
  extends Promise<AsyncIterator<AggregatePlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlanSubscription {
  id: ID_Output;
  serviceId: String;
  service: PaymentService;
  status: SubscriptionStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanSubscriptionPromise
  extends Promise<PlanSubscription>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subscriber: <T = UserPromise>() => T;
  serviceId: () => Promise<String>;
  service: () => Promise<PaymentService>;
  status: () => Promise<SubscriptionStatus>;
  gig: <T = GigPromise>() => T;
  plan: <T = PlanPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanSubscriptionSubscription
  extends Promise<AsyncIterator<PlanSubscription>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subscriber: <T = UserSubscription>() => T;
  serviceId: () => Promise<AsyncIterator<String>>;
  service: () => Promise<AsyncIterator<PaymentService>>;
  status: () => Promise<AsyncIterator<SubscriptionStatus>>;
  gig: <T = GigSubscription>() => T;
  plan: <T = PlanSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanSubscriptionNullablePromise
  extends Promise<PlanSubscription | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subscriber: <T = UserPromise>() => T;
  serviceId: () => Promise<String>;
  service: () => Promise<PaymentService>;
  status: () => Promise<SubscriptionStatus>;
  gig: <T = GigPromise>() => T;
  plan: <T = PlanPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanSubscriptionConnection {
  pageInfo: PageInfo;
  edges: PlanSubscriptionEdge[];
}

export interface PlanSubscriptionConnectionPromise
  extends Promise<PlanSubscriptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlanSubscriptionEdge>>() => T;
  aggregate: <T = AggregatePlanSubscriptionPromise>() => T;
}

export interface PlanSubscriptionConnectionSubscription
  extends Promise<AsyncIterator<PlanSubscriptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlanSubscriptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlanSubscriptionSubscription>() => T;
}

export interface PlanSubscriptionEdge {
  node: PlanSubscription;
  cursor: String;
}

export interface PlanSubscriptionEdgePromise
  extends Promise<PlanSubscriptionEdge>,
    Fragmentable {
  node: <T = PlanSubscriptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlanSubscriptionEdgeSubscription
  extends Promise<AsyncIterator<PlanSubscriptionEdge>>,
    Fragmentable {
  node: <T = PlanSubscriptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlanSubscription {
  count: Int;
}

export interface AggregatePlanSubscriptionPromise
  extends Promise<AggregatePlanSubscription>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlanSubscriptionSubscription
  extends Promise<AsyncIterator<AggregatePlanSubscription>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PortfolioProjectConnection {
  pageInfo: PageInfo;
  edges: PortfolioProjectEdge[];
}

export interface PortfolioProjectConnectionPromise
  extends Promise<PortfolioProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PortfolioProjectEdge>>() => T;
  aggregate: <T = AggregatePortfolioProjectPromise>() => T;
}

export interface PortfolioProjectConnectionSubscription
  extends Promise<AsyncIterator<PortfolioProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PortfolioProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePortfolioProjectSubscription>() => T;
}

export interface PortfolioProjectEdge {
  node: PortfolioProject;
  cursor: String;
}

export interface PortfolioProjectEdgePromise
  extends Promise<PortfolioProjectEdge>,
    Fragmentable {
  node: <T = PortfolioProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PortfolioProjectEdgeSubscription
  extends Promise<AsyncIterator<PortfolioProjectEdge>>,
    Fragmentable {
  node: <T = PortfolioProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePortfolioProject {
  count: Int;
}

export interface AggregatePortfolioProjectPromise
  extends Promise<AggregatePortfolioProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePortfolioProjectSubscription
  extends Promise<AsyncIterator<AggregatePortfolioProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  price: Float;
  codename: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  codename: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  codename: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  codename: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialConnection {
  pageInfo: PageInfo;
  edges: SocialEdge[];
}

export interface SocialConnectionPromise
  extends Promise<SocialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialEdge>>() => T;
  aggregate: <T = AggregateSocialPromise>() => T;
}

export interface SocialConnectionSubscription
  extends Promise<AsyncIterator<SocialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialSubscription>() => T;
}

export interface SocialEdge {
  node: Social;
  cursor: String;
}

export interface SocialEdgePromise extends Promise<SocialEdge>, Fragmentable {
  node: <T = SocialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialEdgeSubscription
  extends Promise<AsyncIterator<SocialEdge>>,
    Fragmentable {
  node: <T = SocialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSocial {
  count: Int;
}

export interface AggregateSocialPromise
  extends Promise<AggregateSocial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialSubscription
  extends Promise<AsyncIterator<AggregateSocial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagCategoryConnection {
  pageInfo: PageInfo;
  edges: TagCategoryEdge[];
}

export interface TagCategoryConnectionPromise
  extends Promise<TagCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagCategoryEdge>>() => T;
  aggregate: <T = AggregateTagCategoryPromise>() => T;
}

export interface TagCategoryConnectionSubscription
  extends Promise<AsyncIterator<TagCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagCategorySubscription>() => T;
}

export interface TagCategoryEdge {
  node: TagCategory;
  cursor: String;
}

export interface TagCategoryEdgePromise
  extends Promise<TagCategoryEdge>,
    Fragmentable {
  node: <T = TagCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagCategoryEdgeSubscription
  extends Promise<AsyncIterator<TagCategoryEdge>>,
    Fragmentable {
  node: <T = TagCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTagCategory {
  count: Int;
}

export interface AggregateTagCategoryPromise
  extends Promise<AggregateTagCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagCategorySubscription
  extends Promise<AsyncIterator<AggregateTagCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ThreadConnection {
  pageInfo: PageInfo;
  edges: ThreadEdge[];
}

export interface ThreadConnectionPromise
  extends Promise<ThreadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThreadEdge>>() => T;
  aggregate: <T = AggregateThreadPromise>() => T;
}

export interface ThreadConnectionSubscription
  extends Promise<AsyncIterator<ThreadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThreadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThreadSubscription>() => T;
}

export interface ThreadEdge {
  node: Thread;
  cursor: String;
}

export interface ThreadEdgePromise extends Promise<ThreadEdge>, Fragmentable {
  node: <T = ThreadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThreadEdgeSubscription
  extends Promise<AsyncIterator<ThreadEdge>>,
    Fragmentable {
  node: <T = ThreadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateThread {
  count: Int;
}

export interface AggregateThreadPromise
  extends Promise<AggregateThread>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThreadSubscription
  extends Promise<AsyncIterator<AggregateThread>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ThreadVoteConnection {
  pageInfo: PageInfo;
  edges: ThreadVoteEdge[];
}

export interface ThreadVoteConnectionPromise
  extends Promise<ThreadVoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThreadVoteEdge>>() => T;
  aggregate: <T = AggregateThreadVotePromise>() => T;
}

export interface ThreadVoteConnectionSubscription
  extends Promise<AsyncIterator<ThreadVoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThreadVoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThreadVoteSubscription>() => T;
}

export interface ThreadVoteEdge {
  node: ThreadVote;
  cursor: String;
}

export interface ThreadVoteEdgePromise
  extends Promise<ThreadVoteEdge>,
    Fragmentable {
  node: <T = ThreadVotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThreadVoteEdgeSubscription
  extends Promise<AsyncIterator<ThreadVoteEdge>>,
    Fragmentable {
  node: <T = ThreadVoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateThreadVote {
  count: Int;
}

export interface AggregateThreadVotePromise
  extends Promise<AggregateThreadVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThreadVoteSubscription
  extends Promise<AsyncIterator<AggregateThreadVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
  isRoot: Boolean;
  isDeleted?: Boolean;
  upvoteCount: Int;
  downvoteCount: Int;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  upvoteCount: () => Promise<Int>;
  downvoteCount: () => Promise<Int>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  upvoteCount: () => Promise<AsyncIterator<Int>>;
  downvoteCount: () => Promise<AsyncIterator<Int>>;
}

export interface CommentVoteSubscriptionPayload {
  mutation: MutationType;
  node: CommentVote;
  updatedFields: String[];
  previousValues: CommentVotePreviousValues;
}

export interface CommentVoteSubscriptionPayloadPromise
  extends Promise<CommentVoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentVotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentVotePreviousValuesPromise>() => T;
}

export interface CommentVoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentVoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentVoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentVotePreviousValuesSubscription>() => T;
}

export interface CommentVotePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  value: Int;
}

export interface CommentVotePreviousValuesPromise
  extends Promise<CommentVotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  value: () => Promise<Int>;
}

export interface CommentVotePreviousValuesSubscription
  extends Promise<AsyncIterator<CommentVotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface EmployerSubscriptionPayload {
  mutation: MutationType;
  node: Employer;
  updatedFields: String[];
  previousValues: EmployerPreviousValues;
}

export interface EmployerSubscriptionPayloadPromise
  extends Promise<EmployerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployerPreviousValuesPromise>() => T;
}

export interface EmployerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployerPreviousValuesSubscription>() => T;
}

export interface EmployerPreviousValues {
  id: ID_Output;
  displayName: String;
  employerType: EmployerType;
  introduction?: String;
  email?: String;
  website?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployerPreviousValuesPromise
  extends Promise<EmployerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  displayName: () => Promise<String>;
  employerType: () => Promise<EmployerType>;
  introduction: () => Promise<String>;
  email: () => Promise<String>;
  website: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployerPreviousValuesSubscription
  extends Promise<AsyncIterator<EmployerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  displayName: () => Promise<AsyncIterator<String>>;
  employerType: () => Promise<AsyncIterator<EmployerType>>;
  introduction: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name?: String;
  contentType?: String;
  url?: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  contentType: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  contentType: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface FreelancerSubscriptionPayload {
  mutation: MutationType;
  node: Freelancer;
  updatedFields: String[];
  previousValues: FreelancerPreviousValues;
}

export interface FreelancerSubscriptionPayloadPromise
  extends Promise<FreelancerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FreelancerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FreelancerPreviousValuesPromise>() => T;
}

export interface FreelancerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FreelancerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FreelancerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FreelancerPreviousValuesSubscription>() => T;
}

export interface FreelancerPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  website?: String;
  location?: String;
  timezone?: String;
  isPrivate?: Boolean;
  isForHire?: Boolean;
  skills: String[];
}

export interface FreelancerPreviousValuesPromise
  extends Promise<FreelancerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  website: () => Promise<String>;
  location: () => Promise<String>;
  timezone: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  isForHire: () => Promise<Boolean>;
  skills: () => Promise<String[]>;
}

export interface FreelancerPreviousValuesSubscription
  extends Promise<AsyncIterator<FreelancerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  timezone: () => Promise<AsyncIterator<String>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  isForHire: () => Promise<AsyncIterator<Boolean>>;
  skills: () => Promise<AsyncIterator<String[]>>;
}

export interface GigSubscriptionPayload {
  mutation: MutationType;
  node: Gig;
  updatedFields: String[];
  previousValues: GigPreviousValues;
}

export interface GigSubscriptionPayloadPromise
  extends Promise<GigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GigPreviousValuesPromise>() => T;
}

export interface GigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GigPreviousValuesSubscription>() => T;
}

export interface GigPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  technologies: String[];
  projectType: ProjectType;
  paymentType: PaymentType;
  minFee: Float;
  maxFee: Float;
  jobType: JobType;
  locationRestriction?: String;
  createdAt: DateTimeOutput;
  status: GigStatus;
  communicationType: GigCommunicationType;
  communicationEmail?: String;
  communicationWebsite?: String;
}

export interface GigPreviousValuesPromise
  extends Promise<GigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  technologies: () => Promise<String[]>;
  projectType: () => Promise<ProjectType>;
  paymentType: () => Promise<PaymentType>;
  minFee: () => Promise<Float>;
  maxFee: () => Promise<Float>;
  jobType: () => Promise<JobType>;
  locationRestriction: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<GigStatus>;
  communicationType: () => Promise<GigCommunicationType>;
  communicationEmail: () => Promise<String>;
  communicationWebsite: () => Promise<String>;
}

export interface GigPreviousValuesSubscription
  extends Promise<AsyncIterator<GigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  technologies: () => Promise<AsyncIterator<String[]>>;
  projectType: () => Promise<AsyncIterator<ProjectType>>;
  paymentType: () => Promise<AsyncIterator<PaymentType>>;
  minFee: () => Promise<AsyncIterator<Float>>;
  maxFee: () => Promise<AsyncIterator<Float>>;
  jobType: () => Promise<AsyncIterator<JobType>>;
  locationRestriction: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<GigStatus>>;
  communicationType: () => Promise<AsyncIterator<GigCommunicationType>>;
  communicationEmail: () => Promise<AsyncIterator<String>>;
  communicationWebsite: () => Promise<AsyncIterator<String>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  serviceRefId: String;
  service: PaymentService;
  status: PaymentStatus;
  cost: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  serviceRefId: () => Promise<String>;
  service: () => Promise<PaymentService>;
  status: () => Promise<PaymentStatus>;
  cost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  serviceRefId: () => Promise<AsyncIterator<String>>;
  service: () => Promise<AsyncIterator<PaymentService>>;
  status: () => Promise<AsyncIterator<PaymentStatus>>;
  cost: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanSubscriptionPayload {
  mutation: MutationType;
  node: Plan;
  updatedFields: String[];
  previousValues: PlanPreviousValues;
}

export interface PlanSubscriptionPayloadPromise
  extends Promise<PlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlanPreviousValuesPromise>() => T;
}

export interface PlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlanPreviousValuesSubscription>() => T;
}

export interface PlanPreviousValues {
  id: ID_Output;
  codename: String;
  serviceId: String;
  status: PlanStatus;
  cyclePrice: Float;
  description?: String;
}

export interface PlanPreviousValuesPromise
  extends Promise<PlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  codename: () => Promise<String>;
  serviceId: () => Promise<String>;
  status: () => Promise<PlanStatus>;
  cyclePrice: () => Promise<Float>;
  description: () => Promise<String>;
}

export interface PlanPreviousValuesSubscription
  extends Promise<AsyncIterator<PlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  codename: () => Promise<AsyncIterator<String>>;
  serviceId: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<PlanStatus>>;
  cyclePrice: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PlanSubscriptionSubscriptionPayload {
  mutation: MutationType;
  node: PlanSubscription;
  updatedFields: String[];
  previousValues: PlanSubscriptionPreviousValues;
}

export interface PlanSubscriptionSubscriptionPayloadPromise
  extends Promise<PlanSubscriptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlanSubscriptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlanSubscriptionPreviousValuesPromise>() => T;
}

export interface PlanSubscriptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlanSubscriptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlanSubscriptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlanSubscriptionPreviousValuesSubscription>() => T;
}

export interface PlanSubscriptionPreviousValues {
  id: ID_Output;
  serviceId: String;
  service: PaymentService;
  status: SubscriptionStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanSubscriptionPreviousValuesPromise
  extends Promise<PlanSubscriptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  serviceId: () => Promise<String>;
  service: () => Promise<PaymentService>;
  status: () => Promise<SubscriptionStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanSubscriptionPreviousValuesSubscription
  extends Promise<AsyncIterator<PlanSubscriptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  serviceId: () => Promise<AsyncIterator<String>>;
  service: () => Promise<AsyncIterator<PaymentService>>;
  status: () => Promise<AsyncIterator<SubscriptionStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PortfolioProjectSubscriptionPayload {
  mutation: MutationType;
  node: PortfolioProject;
  updatedFields: String[];
  previousValues: PortfolioProjectPreviousValues;
}

export interface PortfolioProjectSubscriptionPayloadPromise
  extends Promise<PortfolioProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PortfolioProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PortfolioProjectPreviousValuesPromise>() => T;
}

export interface PortfolioProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PortfolioProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PortfolioProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PortfolioProjectPreviousValuesSubscription>() => T;
}

export interface PortfolioProjectPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  url?: String;
}

export interface PortfolioProjectPreviousValuesPromise
  extends Promise<PortfolioProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
}

export interface PortfolioProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<PortfolioProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  price: Float;
  codename: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  codename: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  codename: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SocialSubscriptionPayload {
  mutation: MutationType;
  node: Social;
  updatedFields: String[];
  previousValues: SocialPreviousValues;
}

export interface SocialSubscriptionPayloadPromise
  extends Promise<SocialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialPreviousValuesPromise>() => T;
}

export interface SocialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialPreviousValuesSubscription>() => T;
}

export interface SocialPreviousValues {
  id: ID_Output;
  type: SocialType;
  url: String;
}

export interface SocialPreviousValuesPromise
  extends Promise<SocialPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<SocialType>;
  url: () => Promise<String>;
}

export interface SocialPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<SocialType>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TagCategorySubscriptionPayload {
  mutation: MutationType;
  node: TagCategory;
  updatedFields: String[];
  previousValues: TagCategoryPreviousValues;
}

export interface TagCategorySubscriptionPayloadPromise
  extends Promise<TagCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagCategoryPreviousValuesPromise>() => T;
}

export interface TagCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagCategoryPreviousValuesSubscription>() => T;
}

export interface TagCategoryPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface TagCategoryPreviousValuesPromise
  extends Promise<TagCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<TagCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ThreadSubscriptionPayload {
  mutation: MutationType;
  node: Thread;
  updatedFields: String[];
  previousValues: ThreadPreviousValues;
}

export interface ThreadSubscriptionPayloadPromise
  extends Promise<ThreadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThreadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThreadPreviousValuesPromise>() => T;
}

export interface ThreadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThreadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThreadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThreadPreviousValuesSubscription>() => T;
}

export interface ThreadPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  body: String;
  upvoteCount: Int;
  downvoteCount: Int;
}

export interface ThreadPreviousValuesPromise
  extends Promise<ThreadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  body: () => Promise<String>;
  upvoteCount: () => Promise<Int>;
  downvoteCount: () => Promise<Int>;
}

export interface ThreadPreviousValuesSubscription
  extends Promise<AsyncIterator<ThreadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  upvoteCount: () => Promise<AsyncIterator<Int>>;
  downvoteCount: () => Promise<AsyncIterator<Int>>;
}

export interface ThreadVoteSubscriptionPayload {
  mutation: MutationType;
  node: ThreadVote;
  updatedFields: String[];
  previousValues: ThreadVotePreviousValues;
}

export interface ThreadVoteSubscriptionPayloadPromise
  extends Promise<ThreadVoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThreadVotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThreadVotePreviousValuesPromise>() => T;
}

export interface ThreadVoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThreadVoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThreadVoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThreadVotePreviousValuesSubscription>() => T;
}

export interface ThreadVotePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  value: Int;
}

export interface ThreadVotePreviousValuesPromise
  extends Promise<ThreadVotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  value: () => Promise<Int>;
}

export interface ThreadVotePreviousValuesSubscription
  extends Promise<AsyncIterator<ThreadVotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email: String;
  password: String;
  role: UserRole;
  accountType?: AccountType;
  createdAt: DateTimeOutput;
  isEmailVerified?: Boolean;
  onboardingStep?: OnboardingStep;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRole>;
  accountType: () => Promise<AccountType>;
  createdAt: () => Promise<DateTimeOutput>;
  isEmailVerified: () => Promise<Boolean>;
  onboardingStep: () => Promise<OnboardingStep>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  accountType: () => Promise<AsyncIterator<AccountType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isEmailVerified: () => Promise<AsyncIterator<Boolean>>;
  onboardingStep: () => Promise<AsyncIterator<OnboardingStep>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "OnboardingStep",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "AccountType",
    embedded: false
  },
  {
    name: "Employer",
    embedded: false
  },
  {
    name: "EmployerType",
    embedded: false
  },
  {
    name: "Freelancer",
    embedded: false
  },
  {
    name: "PortfolioProject",
    embedded: false
  },
  {
    name: "Social",
    embedded: false
  },
  {
    name: "SocialType",
    embedded: false
  },
  {
    name: "GigCommunicationType",
    embedded: false
  },
  {
    name: "GigStatus",
    embedded: false
  },
  {
    name: "Gig",
    embedded: false
  },
  {
    name: "JobType",
    embedded: false
  },
  {
    name: "PaymentType",
    embedded: false
  },
  {
    name: "ProjectType",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "PaymentService",
    embedded: false
  },
  {
    name: "PaymentStatus",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "PlanStatus",
    embedded: false
  },
  {
    name: "Plan",
    embedded: false
  },
  {
    name: "SubscriptionStatus",
    embedded: false
  },
  {
    name: "PlanSubscription",
    embedded: false
  },
  {
    name: "Thread",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "ThreadVote",
    embedded: false
  },
  {
    name: "CommentVote",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "TagCategory",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
